// CayleyGraphVisualizer.jsx
// ---------------------------------------------------------------------------
// Annotated, heavily-commented version of the Cayley graph visualizer.
// Purpose: visualize Cayley graphs of S_n (and A5 preset) using a force-directed
// layout in 3D. This file is intentionally verbose in comments so a reader who
// understands mathematics but is new to React/Three can follow the control flow.
// ---------------------------------------------------------------------------

import React, { useEffect, useMemo, useRef, useState } from "react";
import * as THREE from "three";
import { Canvas, useFrame, useThree } from "@react-three/fiber";
import { OrbitControls, Html } from "@react-three/drei";
import { Matrix4, Quaternion, Vector3 } from "three";

// ---------------------------------------------------------------------------
// PERMUTATION HELPERS
// These small utilities represent permutations as 0-based arrays `p` where
// p[i] = image of i. e.g. identity on 4 points: [0,1,2,3].
// We keep keys as comma-joined strings so Maps can index permutations.
// ---------------------------------------------------------------------------

function idPermutation(n) {
  // return identity permutation of size n as array [0,1,...,n-1]
  return Array.from({ length: n }, (_, i) => i);
}

// parseCycleNotation: convert cycle string like "(1 2)(3 4)" into 0-based perm
// - we deliberately avoid complex regex so the canvas updater doesn't trip on
//   escaping. The parser accepts commas or spaces as separators inside cycles.
function parseCycleNotation(cycleStr, n) {
  const perm = idPermutation(n).slice(); // copy
  if (!cycleStr) return perm;
  let idx = 0;
  while (true) {
    const l = cycleStr.indexOf("(", idx);
    if (l === -1) break;
    const r = cycleStr.indexOf(")", l + 1);
    if (r === -1) break; // unmatched '(', stop
    let inner = cycleStr.slice(l + 1, r).trim();
    // normalize separators: convert commas to spaces and remove double spaces
    while (inner.indexOf(",") !== -1) inner = inner.replace(",", " ");
    while (inner.indexOf("  ") !== -1) inner = inner.replace("  ", " ");
    const parts = inner.length ? inner.split(" ") : [];
    // convert to 0-based ints
    const nums = parts.map((s) => {
      const t = s.trim();
      if (t === "") return NaN;
      const v = parseInt(t, 10);
      if (isNaN(v)) return NaN;
      return v - 1; // convert to 0-based
    }).filter((x) => !isNaN(x));
    // apply cycle: a -> b for successive entries
    for (let i = 0; i < nums.length; i++) {
      const a = nums[i];
      const b = nums[(i + 1) % nums.length];
      perm[a] = b;
    }
    idx = r + 1;
  }
  return perm;
}

function composePerm(a, b) {
  // composition (a ∘ b)(i) = a[b[i]] with 0-based arrays. We treat
  // generator lists as right-multipliers, consistent with the rest of the code.
  const n = a.length;
  const out = new Array(n);
  for (let i = 0; i < n; i++) out[i] = a[b[i]];
  return out;
}

function permToKey(p) {
  // Map-friendly string key for a permutation
  return p.join(",");
}

function permTo1basedString(p) {
  // pretty bracket notation for UI, e.g. [12345]
  return "[" + p.map((x) => x + 1).join("") + "]";
}

function permToCycleString(p) {
  // human-readable disjoint cycle notation (1-based inside)
  const n = p.length;
  const used = new Array(n).fill(false);
  const cycles = [];
  for (let i = 0; i < n; i++) {
    if (used[i]) continue;
    let cur = i;
    if (p[cur] === cur) { used[cur] = true; continue; } // fixed point
    const cycle = [];
    while (!used[cur]) {
      used[cur] = true;
      cycle.push(cur + 1);
      cur = p[cur];
    }
    if (cycle.length > 0) cycles.push("(" + cycle.join(" ") + ")");
  }
  if (cycles.length === 0) return "()"; // identity
  return cycles.join("");
}

// ---------------------------------------------------------------------------
// GROUP GENERATION (BFS)
// We generate the subgroup of S_n generated by the provided generator list
// using breadth-first search. Each nodeObj stores { perm, word } where `word`
// is an array of generator indices in *application order* (we append when
// right-multiplying). This gives shortest words automatically.
// ---------------------------------------------------------------------------

function generateGroup(n, generators) {
  // id permutation
  const id = idPermutation(n);
  const idKey = permToKey(id);
  const seen = new Map(); // key -> {perm, word}
  const queue = [];

  // start from identity, word []
  seen.set(idKey, { perm: id, word: [] });
  queue.push(id);

  while (queue.length) {
    const cur = queue.shift();
    const curKey = permToKey(cur);
    const curEntry = seen.get(curKey);
    // for each generator g_i, compute next = cur ∘ g_i (right multiplication)
    for (let i = 0; i < generators.length; i++) {
      const g = generators[i];
      const next = composePerm(cur, g);
      const k = permToKey(next);
      if (!seen.has(k)) {
        // word = parent's word concat [i]. This stores generator indices
        // in application order. Later we display reversed to read algebraically.
        const wordArr = curEntry.word.concat([i]);
        seen.set(k, { perm: next, word: wordArr });
        queue.push(next);
      }
    }
  }

  // convert map to stable sorted array for reproducible UI order
  const arr = Array.from(seen.values());
  arr.sort((A, B) => {
    const ka = permToKey(A.perm);
    const kb = permToKey(B.perm);
    return ka < kb ? -1 : ka > kb ? 1 : 0;
  });
  return arr;
}

function buildCayley(n, generators) {
  // Build nodes and directed edges for the Cayley graph. Each directed edge
  // corresponds to right-multiplication by a generator: p --g--> p∘g.
  const nodeObjs = generateGroup(n, generators);
  const keyIndex = new Map(nodeObjs.map((o, i) => [permToKey(o.perm), i]));
  const edges = [];
  for (let i = 0; i < nodeObjs.length; i++) {
    const p = nodeObjs[i].perm;
    for (let gi = 0; gi < generators.length; gi++) {
      const next = composePerm(p, generators[gi]);
      const j = keyIndex.get(permToKey(next));
      if (j === undefined) continue; // should not happen if group generation succeeded
      edges.push({ a: i, b: j, gen: gi });
    }
  }
  return { nodeObjs, edges };
}

// ---------------------------------------------------------------------------
// LAYOUT / PHYSICS
// Simple explicit Euler integrator with spring forces along edges, pairwise
// repulsion (optional, O(N^2)), damping and tiny stochastic jostling. Physics
// writes to `positionsRef.current` which is read by the rendering code each
// frame — this avoids React re-renders for each node.
// ---------------------------------------------------------------------------

function initPositions(count, radius = 4) {
  // initialize positions roughly on a circle (3D perturbation) so the graph
  // doesn't start as a singular pile. Returns an array of objects with x,y,z,vx,vy,vz.
  const arr = new Array(count);
  for (let i = 0; i < count; i++) {
    const theta = (2 * Math.PI * i) / Math.max(1, count);
    arr[i] = {
      x: Math.cos(theta) * (radius + (Math.random() - 0.5)),
      y: (Math.random() - 0.5) * 0.3,
      z: Math.sin(theta) * (radius + (Math.random() - 0.5)),
      vx: 0,
      vy: 0,
      vz: 0,
    };
  }
  return arr;
}

function Physics({ positionsRef, edgesRef, pinnedRef, params }) {
  // params: { springK, repulsionK, damping, jostle, running, enableRepulsion }
  const { springK, repulsionK, damping, jostle, running, enableRepulsion } = params;
  useFrame((state, delta) => {
    // clamp dt to avoid instabilities on slow tabs
    const dt = Math.min(delta, 0.04);
    if (!running) return; // allow pause
    const pos = positionsRef.current;
    if (!pos || pos.length === 0) return;
    const count = pos.length;
    // heuristics: choose an "ideal" edge length roughly proportional to cube root
    // of the node count so layouts scale reasonably with graph size.
    const ideal = Math.max(1, Math.pow(Math.max(1, count), 1 / 3)) * 0.9;
    const scale = dt * 60; // scale forces to feel similar across framerates

    // small random jostle to escape degeneracies
    for (let i = 0; i < pos.length; i++) {
      if (pinnedRef.current && pinnedRef.current[i]) continue;
      pos[i].vx += (Math.random() * 2 - 1) * jostle * scale;
      pos[i].vy += (Math.random() * 2 - 1) * jostle * scale;
      pos[i].vz += (Math.random() * 2 - 1) * jostle * scale;
    }

    // spring forces along edges (Hooke-like): F = k (dist - ideal) directed along edge
    const edges = edgesRef.current || [];
    for (let e = 0; e < edges.length; e++) {
      const ed = edges[e];
      const a = pos[ed.a];
      const b = pos[ed.b];
      if (!a || !b) continue;
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dz = b.z - a.z;
      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) + 1e-6;
      const f = springK * (dist - ideal);
      const fx = (f * dx) / dist;
      const fy = (f * dy) / dist;
      const fz = (f * dz) / dist;
      if (!pinnedRef.current[ed.a]) {
        pos[ed.a].vx += fx * 0.5 * scale;
        pos[ed.a].vy += fy * 0.5 * scale;
        pos[ed.a].vz += fz * 0.5 * scale;
      }
      if (!pinnedRef.current[ed.b]) {
        pos[ed.b].vx -= fx * 0.5 * scale;
        pos[ed.b].vy -= fy * 0.5 * scale;
        pos[ed.b].vz -= fz * 0.5 * scale;
      }
    }

    // O(N^2) repulsion (disabled for very large graphs)
    if (enableRepulsion && pos.length <= 720) {
      for (let i = 0; i < pos.length; i++) {
        for (let j = i + 1; j < pos.length; j++) {
          const a = pos[i];
          const b = pos[j];
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const dz = b.z - a.z;
          const dist2 = dx * dx + dy * dy + dz * dz + 1e-6;
          const dist = Math.sqrt(dist2);
          const f = repulsionK / dist2;
          const fx = (f * dx) / dist;
          const fy = (f * dy) / dist;
          const fz = (f * dz) / dist;
          if (!pinnedRef.current[i]) {
            pos[i].vx -= fx * 0.5 * scale;
            pos[i].vy -= fy * 0.5 * scale;
            pos[i].vz -= fz * 0.5 * scale;
          }
          if (!pinnedRef.current[j]) {
            pos[j].vx += fx * 0.5 * scale;
            pos[j].vy += fy * 0.5 * scale;
            pos[j].vz += fz * 0.5 * scale;
          }
        }
      }
    }

    // integrate and apply damping
    for (let i = 0; i < pos.length; i++) {
      if (pinnedRef.current && pinnedRef.current[i]) continue;
      pos[i].x += pos[i].vx * dt;
      pos[i].y += pos[i].vy * dt;
      pos[i].z += pos[i].vz * dt;
      const dampFactor = Math.pow(damping, dt * 60);
      pos[i].vx *= dampFactor;
      pos[i].vy *= dampFactor;
      pos[i].vz *= dampFactor;
    }
  });
  return null; // component does not render anything — it only updates positionsRef
}

// small camera tween when graph size changes so user doesn't have to manually zoom
function AutoCamera({ count }) {
  const { camera } = useThree();
  useEffect(() => {
    const dist = Math.max(12, Math.pow(Math.max(1, count), 1 / 3) * 4);
    const start = camera.position.z;
    const target = dist;
    let t = 0;
    const dur = 20; // frames for the tween
    function step() {
      t++;
      const alpha = Math.min(1, t / dur);
      camera.position.z = start * (1 - alpha) + target * alpha;
      if (alpha < 1) requestAnimationFrame(step);
    }
    step();
  }, [count, camera]);
  return null;
}

// ---------------------------------------------------------------------------
// RENDERING PRIMITIVES (INSTANCING)
// Instanced meshes are used for node spheres and arrow cones so we draw many
// objects with a single GPU draw call. We update instance matrices inside
// useFrame() each animation frame based on positionsRef.current.
// ---------------------------------------------------------------------------

const PALETTE = ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#a65628', '#f781bf', '#999999'];

function InstancedNodes({ positionsRef, count, onClickInstance, onHoverInstance, selectedIdRef, size = 0.14 }) {
  // meshRef is the instancedMesh, dummyMat/q/p are temporary objects reused to
  // avoid GC pressure inside the per-frame loop.
  const meshRef = useRef();
  const dummyMat = useMemo(() => new Matrix4(), []);
  const q = useMemo(() => new Quaternion(), []);
  const p = useMemo(() => new Vector3(), []);

  useFrame(() => {
    const pos = positionsRef.current;
    if (!pos || !meshRef.current) return;
    // write each instance transform from pos[i]
    for (let i = 0; i < pos.length; i++) {
      p.set(pos[i].x, pos[i].y, pos[i].z);
      dummyMat.compose(p, q, new Vector3(size, size, size));
      meshRef.current.setMatrixAt(i, dummyMat);
    }
    meshRef.current.instanceMatrix.needsUpdate = true;
  });

  // pointer events on instanced meshes provide an `instanceId` telling which
  // instance was interacted with. We use that to pin/unpin nodes and to hover.
  const handlePointerDown = (e) => {
    const id = e.instanceId;
    if (id != null && onClickInstance) onClickInstance(id);
  };
  const handlePointerMove = (e) => {
    const id = e.instanceId;
    if (onHoverInstance) onHoverInstance(id);
  };
  const handlePointerOut = () => {
    if (onHoverInstance) onHoverInstance(null);
  };

  return (
    <instancedMesh ref={meshRef} args={[null, null, count]} onPointerDown={handlePointerDown} onPointerMove={handlePointerMove} onPointerOut={handlePointerOut}>
      <sphereGeometry args={[1, 12, 12]} />
      <meshStandardMaterial metalness={0.4} roughness={0.6} />
    </instancedMesh>
  );
}

function EdgeSegments({ edges, positionsRef }) {
  // A single BufferGeometry with 2 vertices per edge (a,b). We also store per-vertex
  // colors so the edge color can reflect the generating element.
  const lineRef = useRef();
  const posArr = useMemo(() => new Float32Array(edges.length * 2 * 3), [edges.length]);
  const colArr = useMemo(() => new Float32Array(edges.length * 2 * 3), [edges.length]);

  useFrame(() => {
    const pos = positionsRef.current;
    if (!pos || !lineRef.current) return;
    for (let i = 0; i < edges.length; i++) {
      const e = edges[i];
      const a = pos[e.a];
      const b = pos[e.b];
      const base = i * 6;
      // defensive guards (a or b might be undefined briefly while positions are being reset)
      if (!a || !b) continue;
      posArr[base + 0] = a.x; posArr[base + 1] = a.y; posArr[base + 2] = a.z;
      posArr[base + 3] = b.x; posArr[base + 4] = b.y; posArr[base + 5] = b.z;
      const col = new THREE.Color(PALETTE[e.gen % PALETTE.length]);
      const r = col.r, g = col.g, bcol = col.b;
      colArr[base + 0] = r; colArr[base + 1] = g; colArr[base + 2] = bcol;
      colArr[base + 3] = r; colArr[base + 4] = g; colArr[base + 5] = bcol;
    }
    const geom = lineRef.current.geometry;
    if (geom.attributes.position) {
      geom.attributes.position.array.set(posArr);
      geom.attributes.position.needsUpdate = true;
    }
    if (geom.attributes.color) {
      geom.attributes.color.array.set(colArr);
      geom.attributes.color.needsUpdate = true;
    }
    geom.computeBoundingSphere();
  });

  return (
    <lineSegments ref={lineRef}>
      <bufferGeometry>
        <bufferAttribute attach="attributes-position" array={posArr} count={posArr.length / 3} itemSize={3} />
        <bufferAttribute attach="attributes-color" array={colArr} count={colArr.length / 3} itemSize={3} />
      </bufferGeometry>
      <lineBasicMaterial attach="material" vertexColors={true} />
    </lineSegments>
  );
}

function ArrowHeads({ edges, positionsRef, size = 0.2 }) {
  // Arrow cones are instantiated; each cone's instance matrix is set so the cone
  // is positioned along the edge and oriented along the edge direction.
  const meshRef = useRef();
  const tmpMat = useMemo(() => new THREE.Matrix4(), []);
  const tmpVec = useMemo(() => new THREE.Vector3(), []);
  const up = useMemo(() => new THREE.Vector3(0, 1, 0), []);
  const q = useMemo(() => new THREE.Quaternion(), []);
  useFrame(() => {
    const pos = positionsRef.current;
    if (!pos || !meshRef.current) return;
    for (let i = 0; i < edges.length; i++) {
      const e = edges[i];
      const a = pos[e.a];
      const b = pos[e.b];
      if (!a || !b) continue;
      tmpVec.set(b.x - a.x, b.y - a.y, b.z - a.z);
      const len = tmpVec.length() || 1;
      const dir = tmpVec.clone().normalize();
      const t = 1 / 3; // position the arrow 2/3 of the way along (closer to head)
      const px = a.x + dir.x * len * t;
      const py = a.y + dir.y * len * t;
      const pz = a.z + dir.z * len * t;
      q.setFromUnitVectors(up, dir); // rotate cone's +Y to align with dir
      tmpMat.compose(new Vector3(px, py, pz), q, new Vector3(size, size, size));
      meshRef.current.setMatrixAt(i, tmpMat);
      // set per-instance color if supported by r3f/three version
      if (meshRef.current.setColorAt) {
        meshRef.current.setColorAt(i, new THREE.Color(PALETTE[e.gen % PALETTE.length]));
      }
    }
    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor) meshRef.current.instanceColor.needsUpdate = true;
  });

  // cone geometry args: [radius, height, radialSegments]
  return (
    <instancedMesh ref={meshRef} args={[null, null, edges.length]}>
      <coneGeometry args={[0.3, 1.9, 12]} />
      <meshStandardMaterial />
    </instancedMesh>
  );
}


// ---------------------------------------------------------------------------
// MAIN UI: controls, presets, and the Canvas + rendered objects
// The left-hand panel holds presets, sliders and the verification list. The
// right-hand side is a full-screen Canvas where the scene is rendered.
// ---------------------------------------------------------------------------

function DebugOverlay({ positionsRef, edgesRef, nodeCount }) {
  // small overlay showing counts to help debug race conditions without crashing
  const [snapshot, setSnapshot] = useState({ posLen: 0, edges: 0 });
  useEffect(() => {
    let raf = null;
    function tick() {
      const posLen = positionsRef.current ? positionsRef.current.length : 0;
      const edgesLen = edgesRef.current ? edgesRef.current.length : 0;
      setSnapshot({ posLen, edges: edgesLen });
      raf = requestAnimationFrame(tick);
    }
    raf = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(raf);
  }, [positionsRef, edgesRef]);

  return (
    <Html position={[3.2, 4.9, 0]} occlude={false} style={{ pointerEvents: 'none' }}>
      <div style={{ background: 'rgba(0,0,0,0.6)', color: '#fff', padding: 8, fontSize: 12, borderRadius: 6 }}>
        <div>nodes (expected): {nodeCount}</div>
        <div>positions.length: {snapshot.posLen}</div>
        <div>edges.length: {snapshot.edges}</div>
      </div>
    </Html>
  );
}

function useThrottledDebugLog(positionsRef, edgesRef, count, enabled = false) {
  const lastRef = useRef(0);
  useFrame(() => {
    if (!enabled) return;
    const now = performance.now();
    if (now - lastRef.current < 500) return;
    lastRef.current = now;
    const posLen = positionsRef.current ? positionsRef.current.length : 0;
    console.log('[DBG] count=%d positions=%d edges=%d sample0=%o', count, posLen, (edgesRef.current||[]).length, positionsRef.current && positionsRef.current[0]);
  });
}

export default function CayleyGraphVisualizer() {
  // group parameters
  const [n, setN] = useState(4);
  const [generatorInput, setGeneratorInput] = useState('(1 2),(1 3),(3 4)');
  const [presets] = useState({
    'S4 polyhedron': { n: 4, gens: ['(1 2)', '(1 3)', '(3 4)'] },
    'A5 dodecahedron-ish': { n: 5, gens: ['(1 2)(3 4)', '(1 2 3 4 5)', '(5 4 3 2 1)'] },
  });
  const [selectedPreset, setSelectedPreset] = useState('S4 polyhedron');

  // physics/UI state (controlled by sliders)
  const [springK, setSpringK] = useState(1.5);
  const [repulsionK, setRepulsionK] = useState(0.12);
  const [damping, setDamping] = useState(0.85);
  const [jostle, setJostle] = useState(0.02);
  const [running, setRunning] = useState(true);
  const [showLabels, setShowLabels] = useState(true);
  const [showDebugOverlay, setShowDebugOverlay] = useState(false);
  const [showElementList, setShowElementList] = useState(true);
  const [enableRepulsion, setEnableRepulsion] = useState(true);

  // when a preset is selected we write its values into n and generatorInput.
  // This effect runs on mount (initial preset) and whenever the preset changes.
  useEffect(() => {
    const p = presets[selectedPreset];
    if (p) {
      setN(p.n);
      setGeneratorInput(p.gens.join(','));
    }
  }, [selectedPreset, presets]);

  // parse input -> names and generators
  const generatorNames = useMemo(() => generatorInput.split(',').map((s) => s.trim()).filter(Boolean), [generatorInput]);
  const shortLabels = useMemo(() => ['R', 'B', 'G', 'P', 'O', 'Y', 'C', 'M'], []);
  // convert textual generators into permutation arrays (0-based)
  const generators = useMemo(() => generatorNames.map((s) => parseCycleNotation(s, n)), [generatorNames, n]);

  // build Cayley graph nodes and edges (purely functional; fast for S4/A5)
  const { nodeObjs, edges } = useMemo(() => buildCayley(n, generators), [n, generators]);
  const count = nodeObjs.length; // number of group elements

  // listing used in the left-hand verification box (shows bracket string, short word label, and cycle notation)
  const listing = useMemo(() => nodeObjs.map((o) => {
    const permStr = permTo1basedString(o.perm);
    const w = o.word; // array of generator indices in application order
    let wordLabel = 'e';
    if (w.length > 0) wordLabel = w.slice().reverse().map((gi) => shortLabels[gi] ?? `g${gi}`).join('');
    return { permStr, wordLabel, cycle: permToCycleString(o.perm) };
  }), [nodeObjs, shortLabels]);

  // positionsRef holds mutable per-node positions used by physics + rendering
  const positionsRef = useRef([]);
  const positionsReadyRef = useRef(false);
  const edgesRef = useRef(edges);
  const pinnedRef = useRef(new Array(count).fill(false)); // which nodes are pinned by clicks
  const selectedIdRef = useRef(null);

  // when the graph changes (different preset / generators) re-seed positions,
  // edgesRef and pinnedRef. This happens synchronously after buildCayley runs.
  useEffect(() => {
    positionsReadyRef.current = false;
    positionsRef.current = initPositions(count, Math.max(3, Math.pow(count, 1 / 3)));
    edgesRef.current = edges;
    pinnedRef.current = new Array(count).fill(false);
    selectedIdRef.current = null;
    // mark ready on next microtask so renderers don't race on the same tick
    Promise.resolve().then(() => { positionsReadyRef.current = true; });
  }, [count, edges]);

  const physicsParams = useMemo(() => ({ springK, repulsionK, damping, jostle, running, enableRepulsion }), [springK, repulsionK, damping, jostle, running, enableRepulsion]);

  const [hoverId, setHoverId] = useState(null); // hovered instance id for Html label

  function handleClickInstance(id) {
    // toggle pinned flag for clicked node
    pinnedRef.current[id] = !pinnedRef.current[id];
    selectedIdRef.current = id;
  }
  function handleHoverInstance(id) { setHoverId(id); }

  // ----------------------------- UI rendering -----------------------------
  return (
    <div className="flex h-screen w-screen">
<div className="w-96 p-4 border-r overflow-auto bg-gray-50 cg-sidebar" style={{ minWidth: 320 }}>
        <h2 className="text-lg font-semibold">Cayley graph visualizer</h2>
        <div className="mt-3">
          <label className="block text-sm">Preset</label>
          <select value={selectedPreset} onChange={(e) => setSelectedPreset(e.target.value)} className="w-full mt-1 p-1 border">
            {Object.keys(presets).map((k) => <option key={k} value={k}>{k}</option>)}
          </select>
        </div>

        <div className="mt-3">
          <label className="block text-sm">n (group S_n)</label>
          <input value={n} onChange={(e) => setN(Number(e.target.value))} type="number" min={2} max={10} className="w-20 mt-1 p-1 border" />
        </div>

        <div className="mt-3">
          <label className="block text-sm">Generators (cycle notation)</label>
          <div className="text-xs text-gray-600 mb-1">Examples: (1 2), (1 2)(3 4), (1 2 3 4 5)</div>
          <input value={generatorInput} onChange={(e) => setGeneratorInput(e.target.value)} className="w-full mt-1 p-1 border text-sm" />
        </div>

        <div className="mt-4">
          <label className="block text-sm">spring K: {springK.toFixed(2)}</label>
          <input type="range" min={0.05} max={10} step={0.01} value={springK} onChange={(e) => setSpringK(parseFloat(e.target.value))} className="w-full" /><br/>
          <label className="block text-sm mt-2">repulsion: {repulsionK.toFixed(3)}</label>
          <input type="range" min={0.00001} max={0.9} step={0.0001} value={repulsionK} onChange={(e) => setRepulsionK(parseFloat(e.target.value))} className="w-full" /><br/>
          <label className="block text-sm mt-2">damping: {damping.toFixed(3)}</label>
          <input type="range" min={0.7} max={0.999} step={0.001} value={damping} onChange={(e) => setDamping(parseFloat(e.target.value))} className="w-full" /><br/>
          <label className="block text-sm mt-2">jostling: {jostle.toFixed(3)}</label>
          <input type="range" min={0} max={0.4} step={0.001} value={jostle} onChange={(e) => setJostle(parseFloat(e.target.value))} className="w-full" /><br/>
        </div>

        <div className="mt-4 flex gap-2">
          <button className="flex-1 bg-green-600 p-2 rounded" onClick={() => setRunning((r) => !r)}>{running ? "Pause" : "Run"}</button>
          <button className="flex-1 bg-blue-600 p-2 rounded" onClick={() => { positionsRef.current = initPositions(count); }}>Re-seed</button>
        </div>

        <div className="mt-4 text-sm text-gray-700">Nodes: {count}  Generators: {generatorNames.length}</div>

        <div className="mt-2 flex gap-2">
          <button className="cg-toggle-btn" onClick={() => setShowLabels(s => !s)}>{showLabels ? 'Hide labels' : 'Show labels'}</button>
          <button className="cg-toggle-btn" onClick={() => setShowDebugOverlay(s => !s)}>{showDebugOverlay ? 'Hide debug' : 'Show debug'}</button>
          <button className="cg-toggle-btn" onClick={() => setShowElementList(s => !s)}>{showElementList ? 'Hide element list' : 'Show element list'}</button>
        </div>

        <div className="mt-4">
          <div className="font-medium">Generators (legend)</div>
          <div className="mt-2">
            {generatorNames.map((g, i) => (
              <div key={i} className="flex items-center gap-2 mt-1">
                <div style={{ width: 12, height: 12, background: PALETTE[i % PALETTE.length], borderRadius: 2 }} />
                <div className="text-sm text-gray-700">{shortLabels[i] ?? `g${i}`} — {g}</div>
              </div>
            ))}
          </div>
        </div>

        <hr className="my-3" />

        {showElementList ? (
  <div>
    <div className="flex items-center justify-between">
      <div className="font-medium mb-2">Elements (verification list)</div>
      <button className="cg-toggle-btn text-sm" onClick={() => setShowElementList(false)}>Hide</button>
    </div>
    <pre className="cg-element-list" style={{ fontFamily: "monospace", fontSize: 12, whiteSpace: "pre-wrap" }}>
      {listing.map((L) => `${L.permStr}: ${L.wordLabel}  ${L.cycle}`).join("\n")}
    </pre>
  </div>
) : (
  <div className="mt-2">
    <button className="cg-toggle-btn" onClick={() => setShowElementList(true)}>Show elements</button>
  </div>
)}
      </div>

      <div className="flex-1 bg-black flex cg-canvas-container">
        <Canvas style={{ width: "100%", height: "90vh" }} dpr={[1, 2]} camera={{ position: [0, 0, Math.max(12, Math.pow(Math.max(1, count), 1 / 3) * 4)], fov: 50 }}>
          <ambientLight intensity={0.6} />
          <directionalLight intensity={0.6} position={[5, 5, 5]} />

          <OrbitControls enableZoom enablePan enableRotate zoomSpeed={0.8} rotateSpeed={0.6} />

          <AutoCamera count={count} />
          <Physics positionsRef={positionsRef} edgesRef={edgesRef} pinnedRef={pinnedRef} params={physicsParams} />

          <EdgeSegments key={`edges-${edges.length}`} edges={edges} positionsRef={positionsRef} color={"#666"} />
          <ArrowHeads key={`arrows-${edges.length}`} edges={edges} positionsRef={positionsRef} color={"#ddd"} size={0.16} />

          <InstancedNodes key={`nodes-${count}`} positionsRef={positionsRef} count={count} onClickInstance={handleClickInstance} onHoverInstance={handleHoverInstance} selectedIdRef={selectedIdRef} />

          {showDebugOverlay && <DebugOverlay positionsRef={positionsRef} edgesRef={edgesRef} nodeCount={count} /> }

          {(() => {
            if (!showLabels) return null;
            const positionsReady = positionsRef.current && positionsReadyRef.current && positionsRef.current.length >= nodeObjs.length;
            if (!positionsReady) return null;
            return nodeObjs.map((o, i) => {
              const posi = positionsRef.current[i];
              if (!posi) return null;
              return (
                <Html key={'label-' + i} distanceFactor={8} style={{ pointerEvents: 'none' }} position={[posi.x, posi.y + 0.28, posi.z]}>
                  <div style={{ background: 'rgba(255,255,255,0.9)', padding: '4px 6px', borderRadius: 4, fontSize: 12 }}>{permTo1basedString(o.perm)}</div>
                </Html>
              );
            });
          })()}

          {showLabels && count > 300 && (
            <Html distanceFactor={8} style={{ pointerEvents: 'none' }} position={[0, 0, 0]}>
              <div style={{ background: 'rgba(255,255,255,0.9)', padding: '6px', borderRadius: 6, fontSize: 12 }}>Labels disabled for large graphs; hover nodes to see a label.</div>
            </Html>
          )}

          {hoverId != null && positionsRef.current && hoverId < positionsRef.current.length && (
            <Html distanceFactor={8} style={{ pointerEvents: "none" }} position={[positionsRef.current[hoverId].x, positionsRef.current[hoverId].y + 0.3, positionsRef.current[hoverId].z]}>
              <div style={{ background: "rgba(255,255,255,0.9)", padding: "6px 8px", borderRadius: 6, fontSize: 12 }}>{permTo1basedString(nodeObjs[hoverId].perm)}<br/>{listing[hoverId].wordLabel}</div>
            </Html>
          )}

        </Canvas>
      </div>
    </div>
  );
}
