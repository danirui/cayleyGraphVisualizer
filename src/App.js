// CayleyGraphVisualizer.jsx
// ---------------------------------------------------------------------------
// Annotated, heavily-commented version of the Cayley graph visualizer.
// Purpose: visualize Cayley graphs of S_n (and A5 preset) using a force-directed
// layout in 3D. This file is intentionally verbose in comments so a reader who
// understands mathematics but is new to React/Three can follow the control flow.
// ---------------------------------------------------------------------------

import React, { useEffect, useMemo, useRef, useState } from "react";
import * as THREE from "three";
import { Canvas, useFrame, useThree } from "@react-three/fiber";
import { OrbitControls, Html } from "@react-three/drei";
import { Matrix4, Quaternion, Vector3 } from "three";

// ---------------------------------------------------------------------------
// PERMUTATION HELPERS
// These small utilities represent permutations as 0-based arrays `p` where
// p[i] = image of i. e.g. identity on 4 points: [0,1,2,3].
// We keep keys as comma-joined strings so Maps can index permutations.
// ---------------------------------------------------------------------------

function idPermutation(n) {
  return Array.from({ length: n }, (_, i) => i);
}

function parseCycleNotation(cycleStr, n) {
  const perm = idPermutation(n).slice();
  if (!cycleStr) return perm;
  let idx = 0;
  while (true) {
    const l = cycleStr.indexOf("(", idx);
    if (l === -1) break;
    const r = cycleStr.indexOf(")", l + 1);
    if (r === -1) break;
    let inner = cycleStr.slice(l + 1, r).trim();
    while (inner.indexOf(",") !== -1) inner = inner.replace(",", " ");
    while (inner.indexOf("  ") !== -1) inner = inner.replace("  ", " ");
    const parts = inner.length ? inner.split(" ") : [];
    const nums = parts
      .map((s) => {
        const t = s.trim();
        if (t === "") return NaN;
        const v = parseInt(t, 10);
        if (isNaN(v)) return NaN;
        return v - 1;
      })
      .filter((x) => !isNaN(x));
    for (let i = 0; i < nums.length; i++) {
      const a = nums[i];
      const b = nums[(i + 1) % nums.length];
      perm[a] = b;
    }
    idx = r + 1;
  }
  return perm;
}

function composePerm(a, b) {
  const n = a.length;
  const out = new Array(n);
  for (let i = 0; i < n; i++) out[i] = a[b[i]];
  return out;
}

function permToKey(p) {
  return p.join(",");
}

function permTo1basedString(p) {
  return "[" + p.map((x) => x + 1).join("") + "]";
}

function permToCycleString(p) {
  const n = p.length;
  const used = new Array(n).fill(false);
  const cycles = [];
  for (let i = 0; i < n; i++) {
    if (used[i]) continue;
    let cur = i;
    if (p[cur] === cur) {
      used[cur] = true;
      continue;
    }
    const cycle = [];
    while (!used[cur]) {
      used[cur] = true;
      cycle.push(cur + 1);
      cur = p[cur];
    }
    if (cycle.length > 0) cycles.push("(" + cycle.join(" ") + ")");
  }
  if (cycles.length === 0) return "()";
  return cycles.join("");
}

// ---------------------------------------------------------------------------
// GROUP GENERATION (BFS)
// We generate the subgroup of S_n generated by the provided generator list
// using breadth-first search. Each nodeObj stores { perm, word } where `word`
// is an array of generator indices in *application order* (we append when
// right-multiplying). This gives shortest words automatically.
// ---------------------------------------------------------------------------

function generateGroup(n, generators) {
  const id = idPermutation(n);
  const idKey = permToKey(id);
  const seen = new Map();
  const queue = [];
  seen.set(idKey, { perm: id, word: [] });
  queue.push(id);
  while (queue.length) {
    const cur = queue.shift();
    const curKey = permToKey(cur);
    const curEntry = seen.get(curKey);
    for (let i = 0; i < generators.length; i++) {
      const g = generators[i];
      const next = composePerm(cur, g);
      const k = permToKey(next);
      if (!seen.has(k)) {
        const wordArr = curEntry.word.concat([i]);
        seen.set(k, { perm: next, word: wordArr });
        queue.push(next);
      }
    }
  }
  const arr = Array.from(seen.values());
  arr.sort((A, B) => {
    const ka = permToKey(A.perm);
    const kb = permToKey(B.perm);
    return ka < kb ? -1 : ka > kb ? 1 : 0;
  });
  return arr;
}

function buildCayley(n, generators) {
  const nodeObjs = generateGroup(n, generators);
  const keyIndex = new Map(nodeObjs.map((o, i) => [permToKey(o.perm), i]));
  const edges = [];
  for (let i = 0; i < nodeObjs.length; i++) {
    const p = nodeObjs[i].perm;
    for (let gi = 0; gi < generators.length; gi++) {
      const next = composePerm(p, generators[gi]);
      const j = keyIndex.get(permToKey(next));
      if (j === undefined) continue;
      edges.push({ a: i, b: j, gen: gi });
    }
  }
  return { nodeObjs, edges };
}

// ---------------------------------------------------------------------------
// LAYOUT / PHYSICS
// Explicit integrator with spring forces along edges, pairwise repulsion,
// damping and stochastic jostling. We implement per-generator tension sliders:
// each generator i has a tension value T_i > 0. We translate 'tension' into an
// edge equilibrium length by: ideal_len_edge = globalIdeal / T_i (so larger
// tension -> shorter target length). The spring force uses springK as a global
// multiplier, and generator-specific tension rescales the rest length.
// ---------------------------------------------------------------------------

function initPositions(count, radius = 4) {
  const arr = new Array(count);
  for (let i = 0; i < count; i++) {
    const theta = (2 * Math.PI * i) / Math.max(1, count);
    arr[i] = {
      x: Math.cos(theta) * (radius + (Math.random() - 0.5)),
      y: (Math.random() - 0.5) * 0.3,
      z: Math.sin(theta) * (radius + (Math.random() - 0.5)),
      vx: 0,
      vy: 0,
      vz: 0,
    };
  }
  return arr;
}

function Physics({
  positionsRef,
  edgesRef,
  pinnedRef,
  params,
  genTensionsRef,
}) {
  const { springK, repulsionK, damping, jostle, running, enableRepulsion } =
    params;
  useFrame((state, delta) => {
    const dt = Math.min(delta, 0.04);
    if (!running) return;
    const pos = positionsRef.current;
    if (!pos || pos.length === 0) return;
    const count = pos.length;
    const idealBase = Math.max(1, Math.pow(Math.max(1, count), 1 / 3)) * 0.9;
    const scale = dt * 60;

    for (let i = 0; i < pos.length; i++) {
      if (pinnedRef.current && pinnedRef.current[i]) continue;
      pos[i].vx += (Math.random() * 2 - 1) * jostle * scale;
      pos[i].vy += (Math.random() * 2 - 1) * jostle * scale;
      pos[i].vz += (Math.random() * 2 - 1) * jostle * scale;
    }

    const edges = edgesRef.current || [];
    for (let e = 0; e < edges.length; e++) {
      const ed = edges[e];
      const a = pos[ed.a];
      const b = pos[ed.b];
      if (!a || !b) continue;
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dz = b.z - a.z;
      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) + 1e-6;

      // generator-specific tension: if undefined fallback 1. We interpret
      // tensionValue > 0 where larger -> shorter target length.
      const tvals = genTensionsRef.current || [];
      const gT = Math.max(1e-3, tvals[ed.gen] || 1.0);
      const effectiveIdeal = idealBase / gT;

      const f = springK * (dist - effectiveIdeal);
      const fx = (f * dx) / dist;
      const fy = (f * dy) / dist;
      const fz = (f * dz) / dist;
      if (!pinnedRef.current[ed.a]) {
        pos[ed.a].vx += fx * 0.5 * scale;
        pos[ed.a].vy += fy * 0.5 * scale;
        pos[ed.a].vz += fz * 0.5 * scale;
      }
      if (!pinnedRef.current[ed.b]) {
        pos[ed.b].vx -= fx * 0.5 * scale;
        pos[ed.b].vy -= fy * 0.5 * scale;
        pos[ed.b].vz -= fz * 0.5 * scale;
      }
    }

    if (enableRepulsion && pos.length <= 720) {
      for (let i = 0; i < pos.length; i++) {
        for (let j = i + 1; j < pos.length; j++) {
          const a = pos[i];
          const b = pos[j];
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const dz = b.z - a.z;
          const dist2 = dx * dx + dy * dy + dz * dz + 1e-6;
          const dist = Math.sqrt(dist2);
          const f = repulsionK / dist2;
          const fx = (f * dx) / dist;
          const fy = (f * dy) / dist;
          const fz = (f * dz) / dist;
          if (!pinnedRef.current[i]) {
            pos[i].vx -= fx * 0.5 * scale;
            pos[i].vy -= fy * 0.5 * scale;
            pos[i].vz -= fz * 0.5 * scale;
          }
          if (!pinnedRef.current[j]) {
            pos[j].vx += fx * 0.5 * scale;
            pos[j].vy += fy * 0.5 * scale;
            pos[j].vz += fz * 0.5 * scale;
          }
        }
      }
    }

    for (let i = 0; i < pos.length; i++) {
      if (pinnedRef.current && pinnedRef.current[i]) continue;
      pos[i].x += pos[i].vx * dt;
      pos[i].y += pos[i].vy * dt;
      pos[i].z += pos[i].vz * dt;
      const dampFactor = Math.pow(damping, dt * 60);
      pos[i].vx *= dampFactor;
      pos[i].vy *= dampFactor;
      pos[i].vz *= dampFactor;
    }
  });
  return null;
}

function AutoCamera({ count }) {
  const { camera } = useThree();
  useEffect(() => {
    const dist = Math.max(12, Math.pow(Math.max(1, count), 1 / 3) * 4);
    const start = camera.position.z;
    const target = dist;
    let t = 0;
    const dur = 20;
    function step() {
      t++;
      const alpha = Math.min(1, t / dur);
      camera.position.z = start * (1 - alpha) + target * alpha;
      if (alpha < 1) requestAnimationFrame(step);
    }
    step();
  }, [count, camera]);
  return null;
}

// ---------------------------------------------------------------------------
// RENDERING (INSTANCING)
// ---------------------------------------------------------------------------

const PALETTE = [
  "#e41a1c",
  "#377eb8",
  "#4daf4a",
  "#984ea3",
  "#ff7f00",
  "#a65628",
  "#f781bf",
  "#999999",
];

const NODE_MODES = {
  NORMAL: 0,
  DRAG: 1,
  PIN: 2,
};

const MODE_COLORS = {
  normal: new THREE.Color("#aaaaaa"), // white-ish
  drag: new THREE.Color("#FFD700"), // gold
  pin: new THREE.Color("#000000"), // black
};

function InstancedNodes({
  positionsRef,
  count,
  onClickInstance,
  onHoverInstance,
  onDragStart,
  onDrag,
  onDragEnd,
  nodeModesRef,
  size = 0.14,
}) {
  const meshRef = useRef();
  const dummyMat = useMemo(() => new Matrix4(), []);
  const q = useMemo(() => new Quaternion(), []);
  const p = useMemo(() => new Vector3(), []);

  // ensure instanceColor attribute is allocated
  useEffect(() => {
    if (!meshRef.current) return;
    const mesh = meshRef.current;
    if (!mesh.instanceColor) {
      // create an InstancedBufferAttribute for colors (rgb per instance)
      const colors = new Float32Array(count * 3);
      const attr = new THREE.InstancedBufferAttribute(colors, 3);
      mesh.geometry.setAttribute("instanceColor", attr);
      mesh.instanceColor = attr;
    }
  }, [count]);

  useFrame(() => {
    const pos = positionsRef.current;
    if (!pos || !meshRef.current) return;
    // update transforms
    for (let i = 0; i < pos.length; i++) {
      p.set(pos[i].x, pos[i].y, pos[i].z);
      dummyMat.compose(p, q, new Vector3(size, size, size));
      meshRef.current.setMatrixAt(i, dummyMat);
    }
    meshRef.current.instanceMatrix.needsUpdate = true;

    // update per-instance colors from nodeModesRef
    const modes = nodeModesRef.current || [];
    if (meshRef.current.instanceColor) {
      const arr = meshRef.current.instanceColor.array;
      for (let i = 0; i < pos.length; i++) {
        const m = modes[i] || "normal";
        const c = MODE_COLORS[m] || MODE_COLORS.normal;
        const base = i * 3;
        arr[base + 0] = c.r;
        arr[base + 1] = c.g;
        arr[base + 2] = c.b;
      }
      meshRef.current.instanceColor.needsUpdate = true;
    }
  });

  // pointer event helpers: react-three-fiber gives `e.point` as the 3d world
  // coordinate of the intersection. We use pointerdown/move/up to implement
  // dragging. Note: the onPointerMove here is called even when not dragging,
  // so we only call onDrag if draggingId is set upstream.

  const handlePointerDown = (e) => {
    e.stopPropagation();
    const id = e.instanceId;
    if (id == null) return;
    // let parent decide what to do on click: cycle modes and possibly start
    // drag. Provide the event point so parent can compute offsets.
    if (onClickInstance) onClickInstance(id, e);
    // also treat this as potential drag start
    if (onDragStart) onDragStart(id, e.point, e);
  };

  const handlePointerMove = (e) => {
    e.stopPropagation();
    const id = e.instanceId;
    if (id == null) {
      // when pointer moved off an instance RTF still calls pointerMove on the
      // mesh with instanceId undefined — in that case call onHoverInstance(null)
      if (onHoverInstance) onHoverInstance(null);
      return;
    }
    if (onHoverInstance) onHoverInstance(id, e);
    // If parent says some node is currently being dragged it will call onDrag
    // from its global pointermove (we also forward here to be safe)
    if (onDrag) onDrag(id, e.point, e);
  };

  const handlePointerUp = (e) => {
    e.stopPropagation();
    const id = e.instanceId;
    if (id == null) return;
    if (onDragEnd) onDragEnd(id, e.point, e);
  };

  const handlePointerOut = (e) => {
    // pointer left the mesh; inform hover cleared
    if (onHoverInstance) onHoverInstance(null);
  };

  return (
    <instancedMesh
      ref={meshRef}
      args={[null, null, count]}
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      onPointerOut={handlePointerOut}
    >
      <sphereGeometry args={[1, 12, 12]} />
      {/* use a material that supports vertex colors via instanceColor */}
      <meshStandardMaterial
        metalness={0.4}
        roughness={0.6}
        vertexColors={true}
      />
    </instancedMesh>
  );
}

function EdgeSegments({ edges, positionsRef }) {
  const lineRef = useRef();
  const posArr = useMemo(
    () => new Float32Array(edges.length * 2 * 3),
    [edges.length]
  );
  const colArr = useMemo(
    () => new Float32Array(edges.length * 2 * 3),
    [edges.length]
  );

  useFrame(() => {
    const pos = positionsRef.current;
    if (!pos || !lineRef.current) return;
    for (let i = 0; i < edges.length; i++) {
      const e = edges[i];
      const a = pos[e.a];
      const b = pos[e.b];
      const base = i * 6;
      if (!a || !b) continue;
      posArr[base + 0] = a.x;
      posArr[base + 1] = a.y;
      posArr[base + 2] = a.z;
      posArr[base + 3] = b.x;
      posArr[base + 4] = b.y;
      posArr[base + 5] = b.z;
      const col = new THREE.Color(PALETTE[e.gen % PALETTE.length]);
      const r = col.r,
        g = col.g,
        bcol = col.b;
      colArr[base + 0] = r;
      colArr[base + 1] = g;
      colArr[base + 2] = bcol;
      colArr[base + 3] = r;
      colArr[base + 4] = g;
      colArr[base + 5] = bcol;
    }
    const geom = lineRef.current.geometry;
    if (geom.attributes.position) {
      geom.attributes.position.array.set(posArr);
      geom.attributes.position.needsUpdate = true;
    }
    if (geom.attributes.color) {
      geom.attributes.color.array.set(colArr);
      geom.attributes.color.needsUpdate = true;
    }
    geom.computeBoundingSphere();
  });

  return (
    <lineSegments ref={lineRef}>
      <bufferGeometry>
        <bufferAttribute
          attach="attributes-position"
          array={posArr}
          count={posArr.length / 3}
          itemSize={3}
        />
        <bufferAttribute
          attach="attributes-color"
          array={colArr}
          count={colArr.length / 3}
          itemSize={3}
        />
      </bufferGeometry>
      <lineBasicMaterial attach="material" vertexColors={true} />
    </lineSegments>
  );
}

function ArrowHeads({ edges, positionsRef, size = 0.2 }) {
  const meshRef = useRef();
  const tmpMat = useMemo(() => new THREE.Matrix4(), []);
  const tmpVec = useMemo(() => new THREE.Vector3(), []);
  const up = useMemo(() => new THREE.Vector3(0, 1, 0), []);
  const q = useMemo(() => new THREE.Quaternion(), []);
  useFrame(() => {
    const pos = positionsRef.current;
    if (!pos || !meshRef.current) return;
    for (let i = 0; i < edges.length; i++) {
      const e = edges[i];
      const a = pos[e.a];
      const b = pos[e.b];
      if (!a || !b) continue;
      tmpVec.set(b.x - a.x, b.y - a.y, b.z - a.z);
      const len = tmpVec.length() || 1;
      const dir = tmpVec.clone().normalize();
      const t = 1 / 3;
      const px = a.x + dir.x * len * t;
      const py = a.y + dir.y * len * t;
      const pz = a.z + dir.z * len * t;
      q.setFromUnitVectors(up, dir);
      tmpMat.compose(new Vector3(px, py, pz), q, new Vector3(size, size, size));
      meshRef.current.setMatrixAt(i, tmpMat);
      if (meshRef.current.setColorAt) {
        meshRef.current.setColorAt(
          i,
          new THREE.Color(PALETTE[e.gen % PALETTE.length])
        );
      }
    }
    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor)
      meshRef.current.instanceColor.needsUpdate = true;
  });

  return (
    <instancedMesh ref={meshRef} args={[null, null, edges.length]}>
      <coneGeometry args={[0.3, 1.9, 12]} />
      <meshStandardMaterial />
    </instancedMesh>
  );
}

// ---------------------------------------------------------------------------
// MAIN UI: controls, presets, and the Canvas + rendered objects
// ---------------------------------------------------------------------------

function DebugOverlay({ positionsRef, edgesRef, nodeCount }) {
  const [snapshot, setSnapshot] = useState({ posLen: 0, edges: 0 });
  useEffect(() => {
    let raf = null;
    function tick() {
      const posLen = positionsRef.current ? positionsRef.current.length : 0;
      const edgesLen = edgesRef.current ? edgesRef.current.length : 0;
      setSnapshot({ posLen, edges: edgesLen });
      raf = requestAnimationFrame(tick);
    }
    raf = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(raf);
  }, [positionsRef, edgesRef]);

  return (
    <Html
      position={[3.2, 4.9, 0]}
      occlude={false}
      style={{ pointerEvents: "none" }}
    >
      <div
        style={{
          background: "rgba(0,0,0,0.6)",
          color: "#fff",
          padding: 8,
          fontSize: 12,
          borderRadius: 6,
        }}
      >
        <div>nodes (expected): {nodeCount}</div>
        <div>positions.length: {snapshot.posLen}</div>
        <div>edges.length: {snapshot.edges}</div>
      </div>
    </Html>
  );
}

export default function CayleyGraphVisualizer() {
  const [n, setN] = useState(4);
  const [generatorInput, setGeneratorInput] = useState("(1 2),(1 3),(3 4)");
  const [presets] = useState({
    "S4 polyhedron": { n: 4, gens: ["(1 2)", "(1 3)", "(3 4)"] },
    "A5 dodecahedron-ish": {
      n: 5,
      gens: ["(1 2)(3 4)", "(1 2 3 4 5)", "(5 4 3 2 1)"],
    },
    "A5 two gens": {
      n: 5,
      gens: ["(1 2 3 4 5)", "(1 2 3 5 4)"],
    },
  });
  const [selectedPreset, setSelectedPreset] = useState("S4 polyhedron");

  const [springK, setSpringK] = useState(1.5);
  const [repulsionK, setRepulsionK] = useState(0.12);
  const [damping, setDamping] = useState(0.85);
  const [jostle, setJostle] = useState(0.02);
  const [running, setRunning] = useState(true);
  const [showLabels, setShowLabels] = useState(true);
  const [showDebugOverlay, setShowDebugOverlay] = useState(false);
  const [showElementList, setShowElementList] = useState(true);
  const [enableRepulsion, setEnableRepulsion] = useState(true);

  useEffect(() => {
    const p = presets[selectedPreset];
    if (p) {
      setN(p.n);
      setGeneratorInput(p.gens.join(","));
    }
  }, [selectedPreset, presets]);

  const generatorNames = useMemo(
    () =>
      generatorInput
        .split(",")
        .map((s) => s.trim())
        .filter(Boolean),
    [generatorInput]
  );
  const shortLabels = useMemo(
    () => ["R", "B", "G", "P", "O", "Y", "C", "M"],
    []
  );
  const generators = useMemo(
    () => generatorNames.map((s) => parseCycleNotation(s, n)),
    [generatorNames, n]
  );

  // per-generator tension state. Default 1.0 for each generator. We provide
  // sliders in the sidebar so the user can tune each generator individually.
  const [genTensions, setGenTensions] = useState(() =>
    generatorNames.map(() => 1.0)
  );
  useEffect(() => {
    // when generator count changes, resize genTensions preserving prefixes
    setGenTensions((old) => {
      const next = generatorNames.map((_, i) =>
        old[i] !== undefined ? old[i] : 1.0
      );
      return next;
    });
  }, [generatorNames.length]);

  const { nodeObjs, edges } = useMemo(
    () => buildCayley(n, generators),
    [n, generators]
  );
  const count = nodeObjs.length;

  const listing = useMemo(
    () =>
      nodeObjs.map((o) => {
        const permStr = permTo1basedString(o.perm);
        const w = o.word;
        let wordLabel = "e";
        if (w.length > 0)
          wordLabel = w
            .slice()
            .reverse()
            .map((gi) => shortLabels[gi] ?? `g${gi}`)
            .join("");
        return { permStr, wordLabel, cycle: permToCycleString(o.perm) };
      }),
    [nodeObjs, shortLabels]
  );

  const positionsRef = useRef([]);
  const positionsReadyRef = useRef(false);
  const edgesRef = useRef(edges);
  const pinnedRef = useRef(new Array(count).fill(false));
  const selectedIdRef = useRef(null);

  useEffect(() => {
    positionsReadyRef.current = false;
    positionsRef.current = initPositions(
      count,
      Math.max(3, Math.pow(count, 1 / 3))
    );
    edgesRef.current = edges;
    pinnedRef.current = new Array(count).fill(false);
    selectedIdRef.current = null;
    Promise.resolve().then(() => {
      positionsReadyRef.current = true;
    });
  }, [count, edges]);

  const genTensionsRef = useRef(genTensions);
  useEffect(() => {
    genTensionsRef.current = genTensions;
  }, [genTensions]);

  const physicsParams = useMemo(
    () => ({ springK, repulsionK, damping, jostle, running, enableRepulsion }),
    [springK, repulsionK, damping, jostle, running, enableRepulsion]
  );

  const [hoverId, setHoverId] = useState(null);

  function handleClickInstance(id) {
    pinnedRef.current[id] = !pinnedRef.current[id];
    selectedIdRef.current = id;
  }
  function handleHoverInstance(id) {
    setHoverId(id);
  }

  // nodeModesRef holds a string mode for each node: 'normal' | 'drag' | 'pin'
  const nodeModesRef = useRef(new Array(count).fill("normal"));
  useEffect(() => {
    // whenever node count changes, resize and preserve prefix
    const old = nodeModesRef.current || [];
    const next = new Array(count);
    for (let i = 0; i < count; i++) next[i] = old[i] || "normal";
    nodeModesRef.current = next;
  }, [count]);

  // dragging state
  const draggingRef = useRef({ id: null, offset: { x: 0, y: 0, z: 0 } });

  // new handlers
  function cycleNodeMode(id) {
    const modes = nodeModesRef.current;
    const cur = modes[id] || "normal";
    let next = "normal";
    if (cur === "normal") next = "drag";
    else if (cur === "drag") next = "pin";
    else if (cur === "pin") next = "normal";
    modes[id] = next;
    nodeModesRef.current = modes;
    // if entering pin mode, mark pinnedRef
    if (next === "pin") pinnedRef.current[id] = true;
    if (next !== "pin") pinnedRef.current[id] = false;
  }

  function handleClickInstance_new(id, event) {
    // Clicking cycles modes and if the new mode is `drag` we mark dragging
    cycleNodeMode(id);
    const modeNow = nodeModesRef.current[id];
    if (modeNow === "drag") {
      // start dragging and compute offset between pointer point and node center
      const pt = event.point;
      const pos = positionsRef.current[id];
      draggingRef.current = {
        id,
        offset: { x: pos.x - pt.x, y: pos.y - pt.y, z: pos.z - pt.z },
      };
      // also prevent physics from updating this node by setting pinned false
      pinnedRef.current[id] = true; // keep it fixed while dragging (but we'll
      // manually move it)
    } else {
      // if we transitioned out of drag mode, clear draggingRef
      if (draggingRef.current.id === id) draggingRef.current = { id: null };
    }
  }

  function handleDragStart(id, point, event) {
    // Some devices (touch) may call dragStart separately. We support it by
    // setting draggingRef similarly.
    const pos = positionsRef.current[id];
    draggingRef.current = {
      id,
      offset: { x: pos.x - point.x, y: pos.y - point.y, z: pos.z - point.z },
    };
    pinnedRef.current[id] = true;
  }

  function handleDrag(id, point, event) {
    if (draggingRef.current.id == null) return;
    const did = draggingRef.current.id;
    if (did !== id) return; // ignore drag events for other instances
    const off = draggingRef.current.offset || { x: 0, y: 0, z: 0 };
    // set the node position directly (it will be rendered next frame)
    positionsRef.current[did].x = point.x + off.x;
    positionsRef.current[did].y = point.y + off.y;
    positionsRef.current[did].z = point.z + off.z;
    // zero velocity so physics doesn't snap it
    positionsRef.current[did].vx = 0;
    positionsRef.current[did].vy = 0;
    positionsRef.current[did].vz = 0;
  }

  function handleDragEnd(id, point, event) {
    if (draggingRef.current.id !== id) return;
    // finish dragging: if node's mode is still 'drag' we keep it in 'drag'
    // mode until the user clicks again to pin it; but we un-mark pinnedRef so
    // that if user wants physics to move it, they can toggle mode.
    pinnedRef.current[id] = nodeModesRef.current[id] === "pin";
    draggingRef.current = { id: null };
  }

  return (
    <div className="flex h-screen w-screen">
      <div
        className="w-96 p-4 border-r overflow-auto bg-gray-50 cg-sidebar"
        style={{ minWidth: 320 }}
      >
        <h2 className="text-lg font-semibold">Cayley graph visualizer</h2>
        <div className="mt-3">
          <label className="block text-sm">Preset</label>
          <select
            value={selectedPreset}
            onChange={(e) => setSelectedPreset(e.target.value)}
            className="w-full mt-1 p-1 border"
          >
            {Object.keys(presets).map((k) => (
              <option key={k} value={k}>
                {k}
              </option>
            ))}
          </select>
        </div>

        <div className="mt-3">
          <label className="block text-sm">n (group S_n)</label>
          <input
            value={n}
            onChange={(e) => setN(Number(e.target.value))}
            type="number"
            min={2}
            max={10}
            className="w-20 mt-1 p-1 border"
          />
        </div>

        <div className="mt-3">
          <label className="block text-sm">Generators (cycle notation)</label>
          <div className="text-xs text-gray-600 mb-1">
            Examples: (1 2), (1 2)(3 4), (1 2 3 4 5)
          </div>
          <input
            value={generatorInput}
            onChange={(e) => setGeneratorInput(e.target.value)}
            className="w-full mt-1 p-1 border text-sm"
          />
        </div>

        <div className="mt-4">
          <label className="block text-sm">
            spring K: {springK.toFixed(2)}
          </label>
          <input
            type="range"
            min={0.05}
            max={10}
            step={0.01}
            value={springK}
            onChange={(e) => setSpringK(parseFloat(e.target.value))}
            className="w-full"
          />
          <br />
          <label className="block text-sm mt-2">
            repulsion: {repulsionK.toFixed(3)}
          </label>
          <input
            type="range"
            min={0.00001}
            max={0.9}
            step={0.0001}
            value={repulsionK}
            onChange={(e) => setRepulsionK(parseFloat(e.target.value))}
            className="w-full"
          />
          <br />
          <label className="block text-sm mt-2">
            damping: {damping.toFixed(3)}
          </label>
          <input
            type="range"
            min={0.7}
            max={0.999}
            step={0.001}
            value={damping}
            onChange={(e) => setDamping(parseFloat(e.target.value))}
            className="w-full"
          />
          <br />
          <label className="block text-sm mt-2">
            jostling: {jostle.toFixed(3)}
          </label>
          <input
            type="range"
            min={0}
            max={0.4}
            step={0.001}
            value={jostle}
            onChange={(e) => setJostle(parseFloat(e.target.value))}
            className="w-full"
          />
          <br />
        </div>

        <div className="mt-4 flex gap-2">
          <button
            className="flex-1 bg-green-600 p-2 rounded"
            onClick={() => setRunning((r) => !r)}
          >
            {running ? "Pause" : "Run"}
          </button>
          <button
            className="flex-1 bg-blue-600 p-2 rounded"
            onClick={() => {
              positionsRef.current = initPositions(count);
            }}
          >
            Re-seed
          </button>
        </div>

        <div className="mt-4 text-sm text-gray-700">
          Nodes: {count} Generators: {generatorNames.length}
        </div>

        <div className="mt-2 flex gap-2">
          <button
            className="cg-toggle-btn"
            onClick={() => setShowLabels((s) => !s)}
          >
            {showLabels ? "Hide labels" : "Show labels"}
          </button>
          <button
            className="cg-toggle-btn"
            onClick={() => setShowDebugOverlay((s) => !s)}
          >
            {showDebugOverlay ? "Hide debug" : "Show debug"}
          </button>
          <button
            className="cg-toggle-btn"
            onClick={() => setShowElementList((s) => !s)}
          >
            {showElementList ? "Hide element list" : "Show element list"}
          </button>
        </div>

        <div className="mt-4">
          <div className="font-medium">Generators (legend)</div>
          <div className="mt-2">
            {generatorNames.map((g, i) => (
              <div key={i} className="flex items-center gap-2 mt-1">
                <div
                  style={{
                    width: 12,
                    height: 12,
                    background: PALETTE[i % PALETTE.length],
                    borderRadius: 2,
                  }}
                />
                <div className="text-sm text-gray-700">
                  {shortLabels[i] ?? `g${i}`} — {g}
                </div>
              </div>
            ))}
          </div>
        </div>

        <hr className="my-3" />

        <div>
          <div className="font-medium">Per-generator tensions</div>
          <div className="text-xs text-gray-600 mb-1">
            Higher tension -{">"} shorter target edges. Slider range: 0.1 .. 5.0
          </div>
          {generatorNames.map((g, i) => (
            <div key={`t-${i}`} className="mt-2">
              <div className="flex items-center justify-between text-sm">
                <div>
                  <span
                    style={{
                      display: "inline-block",
                      width: 12,
                      height: 12,
                      background: PALETTE[i % PALETTE.length],
                      marginRight: 8,
                    }}
                  ></span>
                  {shortLabels[i] ?? `g${i}`} — {g}
                </div>
                <div className="text-xs">{genTensions[i]?.toFixed(2)}</div>
              </div>
              <input
                type="range"
                min={0.1}
                max={5.0}
                step={0.01}
                value={genTensions[i] ?? 1.0}
                onChange={(e) => {
                  const v = parseFloat(e.target.value);
                  setGenTensions((old) => {
                    const next = old.slice();
                    next[i] = v;
                    return next;
                  });
                }}
                className="w-full"
              />
            </div>
          ))}
        </div>

        {showElementList ? (
          <div>
            <div className="flex items-center justify-between">
              <div className="font-medium mb-2">
                Elements (verification list)
              </div>
              <button
                className="cg-toggle-btn text-sm"
                onClick={() => setShowElementList(false)}
              >
                Hide
              </button>
            </div>
            <pre
              className="cg-element-list"
              style={{
                fontFamily: "monospace",
                fontSize: 12,
                whiteSpace: "pre-wrap",
              }}
            >
              {listing
                .map((L) => `${L.permStr}: ${L.wordLabel}  ${L.cycle}`)
                .join("\n")}
            </pre>
          </div>
        ) : (
          <div className="mt-2">
            <button
              className="cg-toggle-btn"
              onClick={() => setShowElementList(true)}
            >
              Show elements
            </button>
          </div>
        )}
      </div>

      <div className="flex-1 bg-black flex cg-canvas-container">
        <Canvas
          style={{ width: "100%", height: "90vh" }}
          dpr={[1, 2]}
          camera={{
            position: [
              0,
              0,
              Math.max(12, Math.pow(Math.max(1, count), 1 / 3) * 4),
            ],
            fov: 50,
          }}
        >
          <ambientLight intensity={0.6} />
          <directionalLight intensity={0.6} position={[5, 5, 5]} />

          <OrbitControls
            enableZoom
            enablePan
            enableRotate
            zoomSpeed={0.8}
            rotateSpeed={0.6}
          />

          <AutoCamera count={count} />
          <Physics
            positionsRef={positionsRef}
            edgesRef={edgesRef}
            pinnedRef={pinnedRef}
            params={physicsParams}
            genTensionsRef={genTensionsRef}
          />

          <EdgeSegments
            key={`edges-${edges.length}`}
            edges={edges}
            positionsRef={positionsRef}
          />
          <ArrowHeads
            key={`arrows-${edges.length}`}
            edges={edges}
            positionsRef={positionsRef}
            size={0.16}
          />

          <InstancedNodes
            key={`nodes-${count}`}
            positionsRef={positionsRef}
            count={count}
            onClickInstance={handleClickInstance_new}
            onHoverInstance={handleHoverInstance}
            onDragStart={handleDragStart}
            onDrag={handleDrag}
            onDragEnd={handleDragEnd}
            nodeModesRef={nodeModesRef}
          />

          {showDebugOverlay && (
            <DebugOverlay
              positionsRef={positionsRef}
              edgesRef={edgesRef}
              nodeCount={count}
            />
          )}

          {(() => {
            if (!showLabels) return null;
            const positionsReady =
              positionsRef.current &&
              positionsReadyRef.current &&
              positionsRef.current.length >= nodeObjs.length;
            if (!positionsReady) return null;
            return nodeObjs.map((o, i) => {
              const posi = positionsRef.current[i];
              if (!posi) return null;
              return (
                <Html
                  key={"label-" + i}
                  distanceFactor={8}
                  style={{ pointerEvents: "none" }}
                  position={[posi.x, posi.y + 0.28, posi.z]}
                >
                  <div
                    style={{
                      background: "rgba(255,255,255,0.9)",
                      padding: "4px 6px",
                      borderRadius: 4,
                      fontSize: 12,
                    }}
                  >
                    {permTo1basedString(o.perm)}
                  </div>
                </Html>
              );
            });
          })()}

          {showLabels && count > 300 && (
            <Html
              distanceFactor={8}
              style={{ pointerEvents: "none" }}
              position={[0, 0, 0]}
            >
              <div
                style={{
                  background: "rgba(255,255,255,0.9)",
                  padding: "6px",
                  borderRadius: 6,
                  fontSize: 12,
                }}
              >
                Labels disabled for large graphs; hover nodes to see a label.
              </div>
            </Html>
          )}

          {hoverId != null &&
            positionsRef.current &&
            hoverId < positionsRef.current.length && (
              <Html
                distanceFactor={8}
                style={{ pointerEvents: "none" }}
                position={[
                  positionsRef.current[hoverId].x,
                  positionsRef.current[hoverId].y + 0.3,
                  positionsRef.current[hoverId].z,
                ]}
              >
                <div
                  style={{
                    background: "rgba(255,255,255,0.9)",
                    padding: "6px 8px",
                    borderRadius: 6,
                    fontSize: 12,
                  }}
                >
                  {permTo1basedString(nodeObjs[hoverId].perm)}
                  <br />
                  {listing[hoverId].wordLabel}
                </div>
              </Html>
            )}
        </Canvas>
      </div>
    </div>
  );
}
