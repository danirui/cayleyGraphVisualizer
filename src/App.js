// CayleyGraphVisualizer.jsx
// ---------------------------------------------------------------------------
// Annotated, heavily-commented version of the Cayley graph visualizer.
// Purpose: visualize Cayley graphs of S_n (and A5 preset) using a force-directed
// layout in 3D. This file is intentionally verbose in comments so a reader who
// understands mathematics but is new to React/Three can follow the control flow.
// ---------------------------------------------------------------------------

import React, { useEffect, useMemo, useRef, useState } from "react";
import * as THREE from "three";
import { Canvas, useFrame, useThree } from "@react-three/fiber";
import { OrbitControls, Html } from "@react-three/drei";
import { Matrix4, Quaternion, Vector3 } from "three";

// ---------------------------------------------------------------------------
// PERMUTATION HELPERS
// These small utilities represent permutations as 0-based arrays `p` where
// p[i] = image of i. e.g. identity on 4 points: [0,1,2,3].
// We keep keys as comma-joined strings so Maps can index permutations.
// ---------------------------------------------------------------------------
function idPermutation(n) {
  return Array.from({ length: n }, (_, i) => i);
}
function parseCycleNotation(cycleStr, n) {
  const perm = idPermutation(n).slice();
  if (!cycleStr) return perm;
  let idx = 0;
  while (true) {
    const l = cycleStr.indexOf("(", idx);
    if (l === -1) break;
    const r = cycleStr.indexOf(")", l + 1);
    if (r === -1) break;
    let inner = cycleStr.slice(l + 1, r).trim();
    while (inner.indexOf(",") !== -1) inner = inner.replace(",", " ");
    while (inner.indexOf("  ") !== -1) inner = inner.replace("  ", " ");
    const parts = inner.length ? inner.split(" ") : [];
    const nums = parts
      .map((s) => {
        const t = s.trim();
        if (t === "") return NaN;
        const v = parseInt(t, 10);
        if (isNaN(v)) return NaN;
        return v - 1;
      })
      .filter((x) => !isNaN(x));
    for (let i = 0; i < nums.length; i++) {
      const a = nums[i];
      const b = nums[(i + 1) % nums.length];
      perm[a] = b;
    }
    idx = r + 1;
  }
  return perm;
}
function composePerm(a, b) {
  const n = a.length;
  const out = new Array(n);
  for (let i = 0; i < n; i++) out[i] = a[b[i]];
  return out;
}
function permToKey(p) {
  return p.join(",");
}
function permTo1basedString(p) {
  return "[" + p.map((x) => x + 1).join("") + "]";
}
function permToCycleString(p) {
  const n = p.length;
  const used = new Array(n).fill(false);
  const cycles = [];
  for (let i = 0; i < n; i++) {
    if (used[i]) continue;
    let cur = i;
    if (p[cur] === cur) {
      used[cur] = true;
      continue;
    }
    const cycle = [];
    while (!used[cur]) {
      used[cur] = true;
      cycle.push(cur + 1);
      cur = p[cur];
    }
    if (cycle.length > 0) cycles.push("(" + cycle.join(" ") + ")");
  }
  if (cycles.length === 0) return "()";
  return cycles.join("");
}
// ---------------------------------------------------------------------------
// GROUP GENERATION (BFS)
// We generate the subgroup of S_n generated by the provided generator list
// using breadth-first search. Each nodeObj stores { perm, word } where `word`
// is an array of generator indices in *application order* (we append when
// right-multiplying). This gives shortest words automatically.
// ---------------------------------------------------------------------------
function generateGroup(n, generators) {
  const id = idPermutation(n);
  const idKey = permToKey(id);
  const seen = new Map();
  const queue = [];
  seen.set(idKey, { perm: id, word: [] });
  queue.push(id);
  while (queue.length) {
    const cur = queue.shift();
    const curKey = permToKey(cur);
    const curEntry = seen.get(curKey);
    for (let i = 0; i < generators.length; i++) {
      const g = generators[i];
      const next = composePerm(cur, g);
      const k = permToKey(next);
      if (!seen.has(k)) {
        const wordArr = curEntry.word.concat([i]);
        seen.set(k, { perm: next, word: wordArr });
        queue.push(next);
      }
    }
  }
  const arr = Array.from(seen.values());
  arr.sort((A, B) => {
    const ka = permToKey(A.perm);
    const kb = permToKey(B.perm);
    return ka < kb ? -1 : ka > kb ? 1 : 0;
  });
  return arr;
}
function buildCayley(n, generators) {
  const nodeObjs = generateGroup(n, generators);
  const keyIndex = new Map(nodeObjs.map((o, i) => [permToKey(o.perm), i]));
  const edges = [];
  for (let i = 0; i < nodeObjs.length; i++) {
    const p = nodeObjs[i].perm;
    for (let gi = 0; gi < generators.length; gi++) {
      const next = composePerm(p, generators[gi]);
      const j = keyIndex.get(permToKey(next));
      if (j === undefined) continue;
      edges.push({ a: i, b: j, gen: gi });
    }
  }
  return { nodeObjs, edges };
}

// ---------------------------------------------------------------------------
// LAYOUT / PHYSICS
// Simple explicit Euler integrator with spring forces along edges, pairwise
// repulsion (optional, O(N^2)), damping and tiny stochastic jostling. Physics
// writes to `positionsRef.current` which is read by the rendering code each
// frame — this avoids React re-renders for each node.
// ---------------------------------------------------------------------------
function initPositions(count, radius = 4) {
  // initialize positions roughly on a circle (3D perturbation) so the graph
  // doesn't start as a singular pile. Returns an array of objects with x,y,z,vx,vy,vz.
  const arr = new Array(count);
  for (let i = 0; i < count; i++) {
    const theta = (2 * Math.PI * i) / Math.max(1, count);
    arr[i] = {
      x: Math.cos(theta) * (radius + (Math.random() - 0.5)),
      y: (Math.random() - 0.5) * 0.3,
      z: Math.sin(theta) * (radius + (Math.random() - 0.5)),
      vx: 0,
      vy: 0,
      vz: 0,
    };
  }
  return arr;
}
function Physics({
  positionsRef,
  edgesRef,
  pinnedRef,
  params,
  genTensionsRef,
}) {
  const { springK, repulsionK, damping, jostle, running, enableRepulsion } =
    params;
  useFrame((state, delta) => {
    const dt = Math.min(delta, 0.04);
    if (!running) return;
    const pos = positionsRef.current;
    if (!pos || pos.length === 0) return;
    const count = pos.length;
    // heuristics: choose an "ideal" edge length roughly proportional to cube root
    // of the node count so layouts scale reasonably with graph size.
    const idealBase = Math.max(1, Math.pow(Math.max(1, count), 1 / 3)) * 0.9;
    const scale = dt * 60;

    for (let i = 0; i < pos.length; i++) {
      if (pinnedRef.current && pinnedRef.current[i]) continue;
      pos[i].vx += (Math.random() * 2 - 1) * jostle * scale;
      pos[i].vy += (Math.random() * 2 - 1) * jostle * scale;
      pos[i].vz += (Math.random() * 2 - 1) * jostle * scale;
    }

    const edges = edgesRef.current || [];
    for (let e = 0; e < edges.length; e++) {
      const ed = edges[e];
      const a = pos[ed.a];
      const b = pos[ed.b];
      if (!a || !b) continue;
      const dx = b.x - a.x;
      const dy = b.y - a.y;
      const dz = b.z - a.z;
      const dist = Math.sqrt(dx * dx + dy * dy + dz * dz) + 1e-6;

      const tvals = genTensionsRef.current || [];
      const gT = tvals[ed.gen] || 0; // tension per edge, zero means no spring
      const k = springK * gT; // spring constant per edge, zero means no spring force
      const effectiveIdeal = idealBase; // fixed ideal length for all edges
      const f = k * (dist - effectiveIdeal);
      const fx = (f * dx) / dist;
      const fy = (f * dy) / dist;
      const fz = (f * dz) / dist;
      if (!pinnedRef.current[ed.a]) {
        pos[ed.a].vx += fx * 0.5 * scale;
        pos[ed.a].vy += fy * 0.5 * scale;
        pos[ed.a].vz += fz * 0.5 * scale;
      }
      if (!pinnedRef.current[ed.b]) {
        pos[ed.b].vx -= fx * 0.5 * scale;
        pos[ed.b].vy -= fy * 0.5 * scale;
        pos[ed.b].vz -= fz * 0.5 * scale;
      }
    }

    if (enableRepulsion && pos.length <= 720) {
      for (let i = 0; i < pos.length; i++) {
        for (let j = i + 1; j < pos.length; j++) {
          const a = pos[i];
          const b = pos[j];
          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const dz = b.z - a.z;
          const dist2 = dx * dx + dy * dy + dz * dz + 1e-6;
          const dist = Math.sqrt(dist2);
          const f = repulsionK / dist2;
          const fx = (f * dx) / dist;
          const fy = (f * dy) / dist;
          const fz = (f * dz) / dist;
          if (!pinnedRef.current[i]) {
            pos[i].vx -= fx * 0.5 * scale;
            pos[i].vy -= fy * 0.5 * scale;
            pos[i].vz -= fz * 0.5 * scale;
          }
          if (!pinnedRef.current[j]) {
            pos[j].vx += fx * 0.5 * scale;
            pos[j].vy += fy * 0.5 * scale;
            pos[j].vz += fz * 0.5 * scale;
          }
        }
      }
    }

    for (let i = 0; i < pos.length; i++) {
      if (pinnedRef.current && pinnedRef.current[i]) continue;
      pos[i].x += pos[i].vx * dt;
      pos[i].y += pos[i].vy * dt;
      pos[i].z += pos[i].vz * dt;
      const dampFactor = Math.pow(damping, dt * 60);
      pos[i].vx *= dampFactor;
      pos[i].vy *= dampFactor;
      pos[i].vz *= dampFactor;
    }
  });
  return null;
}

function AutoCamera({ count }) {
  const { camera } = useThree();
  useEffect(() => {
    const dist = Math.max(12, Math.pow(Math.max(1, count), 1 / 3) * 4);
    const start = camera.position.z;
    const target = dist;
    let t = 0;
    const dur = 20;
    function step() {
      t++;
      const alpha = Math.min(1, t / dur);
      camera.position.z = start * (1 - alpha) + target * alpha;
      if (alpha < 1) requestAnimationFrame(step);
    }
    step();
  }, [count, camera]);
  return null;
}

// ---------------------------------------------------------------------------
// RENDERING PRIMITIVES (INSTANCING)
// Instanced meshes are used for node spheres and arrow cones so we draw many
// objects with a single GPU draw call. We update instance matrices inside
// useFrame() each animation frame based on positionsRef.current.
// ---------------------------------------------------------------------------
const PALETTE = [
  "#e41a1c",
  "#377eb8",
  "#4daf4a",
  "#984ea3",
  "#ff7f00",
  "#a65628",
  "#f781bf",
  "#ffffff",
];

const MODE_COLORS = {
  normal: new THREE.Color(0xffffff),
  drag: new THREE.Color("#FFD700"),
};

function InstancedNodes({
  positionsRef,
  count,
  onClickInstance,
  onHoverInstance,
  onDragStart,
  onDrag,
  onDragEnd,
  nodeModesRef,
  nodesMeshRef, // <-- incoming ref from parent so handlers can change material color
  size = 0.14,
}) {
  const meshRef = useRef();
  const dummyMat = useMemo(() => new Matrix4(), []);
  const q = useMemo(() => new Quaternion(), []);
  const p = useMemo(() => new Vector3(), []);

  const { camera, gl } = useThree();
  const raycasterRef = useRef(new THREE.Raycaster());
  const mouseRef = useRef(new THREE.Vector2());
  const dragPlaneRef = useRef(new THREE.Plane());
  const pointerStateRef = useRef({
    downId: null,
    startX: 0,
    startY: 0,
    dragging: false,
    initialPoint: null,
  });

  useEffect(() => {
    // ensure default material color is gray on mount
    if (meshRef.current && meshRef.current.material) {
      meshRef.current.material.color.set("#ffffff");
      if (nodesMeshRef) nodesMeshRef.current = meshRef.current;
    }
  }, [count, nodesMeshRef]);

  // cleanup listeners on unmount
  useEffect(() => {
    return () => {
      try {
        if (typeof window !== "undefined") {
          window.removeEventListener("pointermove", globalPointerMove);
          window.removeEventListener("pointerup", globalPointerUp);
        }
      } catch (_) {}
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // helper functions for global pointer events
  const globalPointerMove = (ev) => {
    const ps = pointerStateRef.current;
    if (!ps.dragging || ps.downId == null) return;
    const rect = gl.domElement.getBoundingClientRect();
    mouseRef.current.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
    mouseRef.current.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
    raycasterRef.current.setFromCamera(mouseRef.current, camera);
    const plane = dragPlaneRef.current;
    const intersect = new THREE.Vector3();
    if (raycasterRef.current.ray.intersectPlane(plane, intersect)) {
      if (onDrag) onDrag(ps.downId, intersect, ev);
    }
  };
  const globalPointerUp = (ev) => {
    const ps = pointerStateRef.current;
    if (!ps) return;
    if (ps.dragging) {
      if (onDragEnd) onDragEnd(ps.downId, null, ev);
    }
    ps.downId = null;
    ps.dragging = false;
    ps.initialPoint = null;
    try {
      if (typeof window !== "undefined") {
        window.removeEventListener("pointermove", globalPointerMove);
        window.removeEventListener("pointerup", globalPointerUp);
      }
    } catch (_) {}
  };

  useFrame(() => {
    const pos = positionsRef.current;
    if (!pos || !meshRef.current) return;

    // update instance transforms
    for (let i = 0; i < pos.length; i++) {
      p.set(pos[i].x, pos[i].y, pos[i].z);
      dummyMat.compose(p, q, new Vector3(size, size, size));
      meshRef.current.setMatrixAt(i, dummyMat);
    }
    meshRef.current.instanceMatrix.needsUpdate = true;
    // NOTE: we no longer update per-instance colors here
  });

  // pointer handling (click toggles mode; hold+move starts drag)
  const onPointerDown = (e) => {
    e.stopPropagation();
    const id = e.instanceId;
    if (id == null) return;
    try {
      e.target.setPointerCapture && e.target.setPointerCapture(e.pointerId);
    } catch (_) {}
    pointerStateRef.current.downId = id;
    pointerStateRef.current.startX = e.clientX;
    pointerStateRef.current.startY = e.clientY;
    pointerStateRef.current.initialPoint = e.point;
    pointerStateRef.current.dragging = false;
  };

  const onPointerMove = (e) => {
    e.stopPropagation();
    const id = e.instanceId;
    if (id == null) {
      if (onHoverInstance) onHoverInstance(null);
      return;
    }
    if (onHoverInstance) onHoverInstance(id, e);

    const ps = pointerStateRef.current;
    if (ps.downId === id && !ps.dragging) {
      const dx = e.clientX - ps.startX;
      const dy = e.clientY - ps.startY;
      const dist2 = dx * dx + dy * dy;
      const THRESH = 6; // pixels
      if (dist2 > THRESH * THRESH) {
        // start dragging
        ps.dragging = true;
        // setup drag plane through current node position, facing camera
        const pos = positionsRef.current[id];
        const camDir = new THREE.Vector3();
        camera.getWorldDirection(camDir);
        dragPlaneRef.current.setFromNormalAndCoplanarPoint(
          camDir,
          new THREE.Vector3(pos.x, pos.y, pos.z)
        );
        // attach global listeners
        if (typeof window !== "undefined") {
          window.addEventListener("pointermove", globalPointerMove);
          window.addEventListener("pointerup", globalPointerUp);
        }
        if (onDragStart) onDragStart(id, e.point, e);
      }
    }
  };

  const onPointerUp = (e) => {
    e.stopPropagation();
    const id = e.instanceId;
    try {
      e.target.releasePointerCapture &&
        e.target.releasePointerCapture(e.pointerId);
    } catch (_) {}
    const ps = pointerStateRef.current;
    if (!ps) return;
    if (ps.downId === id) {
      if (!ps.dragging) {
        // treat as click toggle
        if (onClickInstance) onClickInstance(id, e);
      } else {
        // if dragging ended via pointerup on mesh, handle end
        if (onDragEnd) onDragEnd(id, e.point, e);
      }
      ps.downId = null;
      ps.dragging = false;
      ps.initialPoint = null;
      try {
        if (typeof window !== "undefined") {
          window.removeEventListener("pointermove", globalPointerMove);
          window.removeEventListener("pointerup", globalPointerUp);
        }
      } catch (_) {}
    }
  };

  const onPointerOut = (e) => {
    if (onHoverInstance) onHoverInstance(null);
  };

  return (
    <instancedMesh
      ref={(r) => {
        meshRef.current = r;
        if (nodesMeshRef) nodesMeshRef.current = r;
      }}
      args={[null, null, count]}
      onPointerDown={onPointerDown}
      onPointerMove={onPointerMove}
      onPointerUp={onPointerUp}
      onPointerOut={onPointerOut}
    >
      <sphereGeometry args={[1, 12, 12]} />
      <meshStandardMaterial
        metalness={0.4}
        roughness={0.6}
        vertexColors={false}
      />
    </instancedMesh>
  );
}

function EdgeSegments({ edges, positionsRef }) {
  const lineRef = useRef();
  const posArr = useMemo(
    () => new Float32Array(edges.length * 2 * 3),
    [edges.length]
  );
  const colArr = useMemo(
    () => new Float32Array(edges.length * 2 * 3),
    [edges.length]
  );

  useFrame(() => {
    const pos = positionsRef.current;
    if (!pos || !lineRef.current) return;
    for (let i = 0; i < edges.length; i++) {
      const e = edges[i];
      const a = pos[e.a];
      const b = pos[e.b];
      const base = i * 6;
      if (!a || !b) continue;
      posArr[base + 0] = a.x;
      posArr[base + 1] = a.y;
      posArr[base + 2] = a.z;
      posArr[base + 3] = b.x;
      posArr[base + 4] = b.y;
      posArr[base + 5] = b.z;
      const col = new THREE.Color(PALETTE[e.gen % PALETTE.length]);
      colArr[base + 0] = col.r;
      colArr[base + 1] = col.g;
      colArr[base + 2] = col.b;
      colArr[base + 3] = col.r;
      colArr[base + 4] = col.g;
      colArr[base + 5] = col.b;
    }
    const geom = lineRef.current.geometry;
    if (geom.attributes.position) {
      geom.attributes.position.array.set(posArr);
      geom.attributes.position.needsUpdate = true;
    }
    if (geom.attributes.color) {
      geom.attributes.color.array.set(colArr);
      geom.attributes.color.needsUpdate = true;
    }
    geom.computeBoundingSphere();
  });

  return (
    <lineSegments ref={lineRef}>
      <bufferGeometry>
        <bufferAttribute
          attach="attributes-position"
          array={posArr}
          count={posArr.length / 3}
          itemSize={3}
        />
        <bufferAttribute
          attach="attributes-color"
          array={colArr}
          count={colArr.length / 3}
          itemSize={3}
        />
      </bufferGeometry>
      <lineBasicMaterial attach="material" vertexColors={true} />
    </lineSegments>
  );
}

function ArrowHeads({ edges, positionsRef, size = 0.2 }) {
  const meshRef = useRef();
  const tmpMat = useMemo(() => new THREE.Matrix4(), []);
  const tmpVec = useMemo(() => new THREE.Vector3(), []);
  const up = useMemo(() => new THREE.Vector3(0, 1, 0), []);
  const q = useMemo(() => new THREE.Quaternion(), []);
  useFrame(() => {
    const pos = positionsRef.current;
    if (!pos || !meshRef.current) return;
    for (let i = 0; i < edges.length; i++) {
      const e = edges[i];
      const a = pos[e.a];
      const b = pos[e.b];
      if (!a || !b) continue;
      tmpVec.set(b.x - a.x, b.y - a.y, b.z - a.z);
      const len = tmpVec.length() || 1;
      const dir = tmpVec.clone().normalize();
      const t = 1 / 3;
      const px = a.x + dir.x * len * t;
      const py = a.y + dir.y * len * t;
      const pz = a.z + dir.z * len * t;
      q.setFromUnitVectors(up, dir);
      tmpMat.compose(new Vector3(px, py, pz), q, new Vector3(size, size, size));
      meshRef.current.setMatrixAt(i, tmpMat);
      const basecolor = PALETTE[e.gen % PALETTE.length];
      if (meshRef.current.setColorAt)
        meshRef.current.setColorAt(i, new THREE.Color(basecolor));
    }
    meshRef.current.instanceMatrix.needsUpdate = true;
    if (meshRef.current.instanceColor)
      meshRef.current.instanceColor.needsUpdate = true;
  });
  // https://threejs.org/docs/#api/en/lights/DirectionalLight
  return (
    <instancedMesh ref={meshRef} args={[null, null, edges.length]}>
      <coneGeometry args={[0.3, 1.9, 12]} />
      <ambientLight intensity={7} color="#777777" />
      <directionalLight intensity={7} color="#bbbbbb" />
      <meshStandardMaterial />
    </instancedMesh>
  );
}

// ---------------------------------------------------------------------------
// MAIN UI: controls, presets, and the Canvas + rendered objects
// The left-hand panel holds presets, sliders and the verification list. The
// right-hand side is a full-screen Canvas where the scene is rendered.
// ---------------------------------------------------------------------------
function DebugOverlay({ positionsRef, edgesRef, nodeCount }) {
  const [snapshot, setSnapshot] = useState({ posLen: 0, edges: 0 });
  useEffect(() => {
    let raf = null;
    function tick() {
      const posLen = positionsRef.current ? positionsRef.current.length : 0;
      const edgesLen = edgesRef.current ? edgesRef.current.length : 0;
      setSnapshot({ posLen, edges: edgesLen });
      raf = requestAnimationFrame(tick);
    }
    raf = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(raf);
  }, [positionsRef, edgesRef]);

  return (
    <Html
      position={[3.2, 4.9, 0]}
      occlude={false}
      style={{ pointerEvents: "none" }}
    >
      <div
        style={{
          background: "rgba(0,0,0,0.6)",
          color: "#fff",
          padding: 8,
          fontSize: 12,
          borderRadius: 6,
        }}
      >
        <div>nodes (expected): {nodeCount}</div>
        <div>positions.length: {snapshot.posLen}</div>
        <div>edges.length: {snapshot.edges}</div>
      </div>
    </Html>
  );
}

export default function CayleyGraphVisualizer() {
  const [n, setN] = useState(4);
  const [generatorInput, setGeneratorInput] = useState("(1 2),(1 3),(3 4)");
  const [presets] = useState({
    "S4 polyhedron": { n: 4, gens: ["(1 2)", "(1 3)", "(3 4)"] },
    "A5 dodecahedron-ish": {
      n: 5,
      gens: ["(1 2)(3 4)", "(1 2 3 4 5)", "(5 4 3 2 1)"],
    },
    "A5 two gens": { n: 5, gens: ["(1 2 3 4 5)", "(1 2 3 5 4)"] },
  });
  const [selectedPreset, setSelectedPreset] = useState("S4 polyhedron");

  const [springK, setSpringK] = useState(1.5);
  const [repulsionK, setRepulsionK] = useState(0.22);
  const [damping, setDamping] = useState(0.85);
  const [jostle, setJostle] = useState(0.02);
  const [running, setRunning] = useState(true);
  const [showLabels, setShowLabels] = useState(true);
  const [showDebugOverlay, setShowDebugOverlay] = useState(false);
  const [showElementList, setShowElementList] = useState(true);
  const [enableRepulsion, setEnableRepulsion] = useState(true);

  useEffect(() => {
    const p = presets[selectedPreset];
    if (p) {
      setN(p.n);
      setGeneratorInput(p.gens.join(","));
    }
  }, [selectedPreset, presets]);

  const generatorNames = useMemo(
    () =>
      generatorInput
        .split(",")
        .map((s) => s.trim())
        .filter(Boolean),
    [generatorInput]
  );
  const shortLabels = useMemo(
    () => ["R", "B", "G", "L", "O", "T", "P", "S"],
    []
  );
  const generators = useMemo(
    () => generatorNames.map((s) => parseCycleNotation(s, n)),
    [generatorNames, n]
  );

  const [genTensions, setGenTensions] = useState(() =>
    generatorNames.map(() => 1.0)
  );
  useEffect(() => {
    setGenTensions((old) => {
      const next = generatorNames.map((_, i) =>
        old[i] !== undefined ? old[i] : 1.0
      );
      return next;
    });
  }, [generatorNames.length]);

  const { nodeObjs, edges } = useMemo(
    () => buildCayley(n, generators),
    [n, generators]
  );
  const count = nodeObjs.length;

  const listing = useMemo(
    () =>
      nodeObjs.map((o) => {
        const permStr = permTo1basedString(o.perm);
        const w = o.word;
        let wordLabel = "e";
        if (w.length > 0)
          wordLabel = w
            .slice()
            .reverse()
            .map((gi) => shortLabels[gi] ?? `g${gi}`)
            .join("");
        return { permStr, wordLabel, cycle: permToCycleString(o.perm) };
      }),
    [nodeObjs, shortLabels]
  );

  const positionsRef = useRef([]);
  const positionsReadyRef = useRef(false);
  const edgesRef = useRef(edges);
  const pinnedRef = useRef(new Array(count).fill(false));
  const selectedIdRef = useRef(null);

  useEffect(() => {
    positionsReadyRef.current = false;
    positionsRef.current = initPositions(
      count,
      Math.max(3, Math.pow(count, 1 / 3))
    );
    edgesRef.current = edges;
    pinnedRef.current = new Array(count).fill(false);
    selectedIdRef.current = null;
    Promise.resolve().then(() => {
      positionsReadyRef.current = true;
    });
  }, [count, edges]);

  const genTensionsRef = useRef(genTensions);
  useEffect(() => {
    genTensionsRef.current = genTensions;
  }, [genTensions]);

  const physicsParams = useMemo(
    () => ({ springK, repulsionK, damping, jostle, running, enableRepulsion }),
    [springK, repulsionK, damping, jostle, running, enableRepulsion]
  );

  const [hoverId, setHoverId] = useState(null);

  // ----------------- NEW: node mode & dragging logic -----------------
  // modes: 'normal' | 'drag' | 'pin'
  const nodeModesRef = useRef(new Array(count).fill("normal"));
  useEffect(() => {
    const old = nodeModesRef.current || [];
    const next = new Array(count);
    for (let i = 0; i < count; i++) next[i] = old[i] || "normal";
    nodeModesRef.current = next;
  }, [count]);

  const draggingRef = useRef({ id: null, offset: { x: 0, y: 0, z: 0 } });
  const controlsRef = useRef();
  const nodesMeshRef = useRef(null);

  useEffect(() => {
    if (nodesMeshRef.current) {
      console.log(
        "instanceColor attr:",
        nodesMeshRef.current.geometry.getAttribute("instanceColor")
      );
      console.log(
        "first 9 values:",
        nodesMeshRef.current.geometry
          .getAttribute("instanceColor")
          ?.array?.slice(0, 9)
      );
    }
  }, []);

  // helper to (lazily) ensure the instanceColor attribute exists and is initialized to gray
  function ensureInstanceColorAttribute(mesh) {
    if (!mesh) return null;
    const geom = mesh.geometry;
    if (!geom) return null;
    let attr = geom.getAttribute("instanceColor");
    console.log(attr);
    const num = Math.max(1, count);
    if (!attr || attr.array.length < num * 3) {
      const arr = new Float32Array(num * 3);
      // initialize all entries to default gray (#ffffff)
      const gray = new THREE.Color("#ffffff");
      for (let i = 0; i < num; i++) {
        const base = i * 3;
        arr[base + 0] = gray.r;
        arr[base + 1] = gray.g;
        arr[base + 2] = gray.b;
      }
      attr = new THREE.InstancedBufferAttribute(arr, 3);
      geom.setAttribute("instanceColor", attr);

      // also set convenience pointer on the mesh so three.js/r3f shader sees it reliably
      mesh.instanceColor = attr;
      // ensure the gpu copy will update
      attr.needsUpdate = true;
    } else {
      // make sure mesh.instanceColor points to this attribute
      mesh.instanceColor = attr;
    }
    return attr;
  }

  // set a single instance color (hex string), creates attribute if needed
  function setInstanceColor(id, hex) {
    const mesh = nodesMeshRef.current;
    if (!mesh) return;
    const geom = mesh.geometry;
    if (!geom) return;
    let attr = geom.getAttribute("instanceColor");
    if (!attr) {
      attr = ensureInstanceColorAttribute(mesh);
      if (!attr) return;
    }
    const arr = attr.array;
    const c = new THREE.Color(hex);
    const base = id * 3;
    arr[base + 0] = c.r;
    arr[base + 1] = c.g;
    arr[base + 2] = c.b;
    // mark both attribute and mesh pointer as updated
    attr.needsUpdate = true;
    if (mesh.instanceColor) mesh.instanceColor.needsUpdate = true;
  }

  // On mount or whenever count changes, ensure default gray is present
  useEffect(() => {
    // if mesh already created, ensure attribute exists & initialized
    if (nodesMeshRef.current) {
      ensureInstanceColorAttribute(nodesMeshRef.current);
    }
    // otherwise lazy init will occur on first setInstanceColor call
  }, [count]);

  function handleClickInstance_new(id, event) {
    const modes = nodeModesRef.current;
    const cur = modes[id] || "normal";
    const next = cur === "normal" ? "drag" : "normal";
    modes[id] = next;
    nodeModesRef.current = modes;
    // when in drag mode we pin and disable camera controls; when returning to normal we unpin
    pinnedRef.current[id] = next === "drag";
    if (next === "drag") {
      if (controlsRef.current) controlsRef.current.enabled = false;
    } else {
      if (draggingRef.current.id === id)
        draggingRef.current = { id: null, offset: { x: 0, y: 0, z: 0 } };
      if (controlsRef.current) controlsRef.current.enabled = true;
    }

    // single-line: set this instance to gold (or back to gray)
    if (nodeModesRef.current[id] === "drag") {
      setInstanceColor(id, "#FFD700");
    } else {
      setInstanceColor(id, "#ffffff");
    }
  }

  function handleDragStart(id, point, event) {
    const pos = positionsRef.current[id];
    draggingRef.current = {
      id,
      offset: { x: pos.x - point.x, y: pos.y - point.y, z: pos.z - point.z },
    };
    pinnedRef.current[id] = true;
    nodeModesRef.current[id] = "drag";
    if (controlsRef.current) controlsRef.current.enabled = false;

    // single-line: during drag set this instance to gold
    setInstanceColor(id, "#FFD700");
  }

  function handleDrag(id, point, event) {
    if (draggingRef.current.id == null) return;
    const did = draggingRef.current.id;
    if (did !== id) return;
    const off = draggingRef.current.offset || { x: 0, y: 0, z: 0 };
    positionsRef.current[did].x = point.x + off.x;
    positionsRef.current[did].y = point.y + off.y;
    positionsRef.current[did].z = point.z + off.z;
    positionsRef.current[did].vx = 0;
    positionsRef.current[did].vy = 0;
    positionsRef.current[did].vz = 0;
  }

  function handleDragEnd(id, point, event) {
    if (draggingRef.current.id !== id) return;
    pinnedRef.current[id] = nodeModesRef.current[id] === "pin";
    draggingRef.current = { id: null };
    if (controlsRef.current) controlsRef.current.enabled = true;

    // single-line: revert this instance to normal gray
    setInstanceColor(id, "#ffffff");
  }

  function handleHoverInstance(id) {
    setHoverId(id);
  }
  // ----------------- END new logic -----------------

  return (
    <div className="flex h-screen w-screen cg-layout">
      <div
        className="w-96 p-4 border-r overflow-auto bg-gray-50 cg-sidebar"
        style={{ minWidth: 320 }}
      >
        <h2 className="text-lg font-semibold">Cayley graph visualizer</h2>
        <div className="mt-3">
          <label className="block text-sm">Preset</label>
          <select
            value={selectedPreset}
            onChange={(e) => setSelectedPreset(e.target.value)}
            className="w-full mt-1 p-1 border"
          >
            {Object.keys(presets).map((k) => (
              <option key={k} value={k}>
                {k}
              </option>
            ))}
          </select>
        </div>

        <div className="mt-3">
          <label className="block text-sm">n (group S_n)</label>
          <input
            value={n}
            onChange={(e) => setN(Number(e.target.value))}
            type="number"
            min={2}
            max={10}
            className="w-20 mt-1 p-1 border"
          />
        </div>

        <div className="mt-3">
          <label className="block text-sm">Generators (cycle notation)</label>
          <div className="text-xs text-gray-600 mb-1">
            Examples: (1 2), (1 2)(3 4), (1 2 3 4 5)
          </div>
          <input
            value={generatorInput}
            onChange={(e) => setGeneratorInput(e.target.value)}
            className="w-full mt-1 p-1 border text-sm"
          />
        </div>

        <div className="mt-4">
          <label className="block text-sm">
            spring K: {springK.toFixed(2)}
          </label>
          <input
            type="range"
            min={0.05}
            max={10}
            step={0.01}
            value={springK}
            onChange={(e) => setSpringK(parseFloat(e.target.value))}
            className="w-full"
          />
          <br />
          <label className="block text-sm mt-2">
            repulsion: {repulsionK.toFixed(3)}
          </label>
          <input
            type="range"
            min={0.00001}
            max={0.9}
            step={0.0001}
            value={repulsionK}
            onChange={(e) => setRepulsionK(parseFloat(e.target.value))}
            className="w-full"
          />
          <br />
          <label className="block text-sm mt-2">
            damping: {damping.toFixed(3)}
          </label>
          <input
            type="range"
            min={0.7}
            max={0.999}
            step={0.001}
            value={damping}
            onChange={(e) => setDamping(parseFloat(e.target.value))}
            className="w-full"
          />
          <br />
          <label className="block text-sm mt-2">
            jostling: {jostle.toFixed(3)}
          </label>
          <input
            type="range"
            min={0}
            max={0.4}
            step={0.001}
            value={jostle}
            onChange={(e) => setJostle(parseFloat(e.target.value))}
            className="w-full"
          />
          <br />
        </div>

        <div className="mt-4 flex gap-2">
          <button
            className="flex-1 bg-green-600 p-2 rounded"
            onClick={() => setRunning((r) => !r)}
          >
            {running ? "Pause" : "Run"}
          </button>
          <button
            className="flex-1 bg-blue-600 p-2 rounded"
            onClick={() => {
              positionsRef.current = initPositions(count);
            }}
          >
            Re-seed
          </button>
        </div>

        <div className="mt-4 text-sm text-gray-700">
          Nodes: {count} Generators: {generatorNames.length}
        </div>

        <div className="mt-2 flex gap-2">
          <button
            className="cg-toggle-btn"
            onClick={() => setShowLabels((s) => !s)}
          >
            {showLabels ? "Hide labels" : "Show labels"}
          </button>
          <button
            className="cg-toggle-btn"
            onClick={() => setShowDebugOverlay((s) => !s)}
          >
            {showDebugOverlay ? "Hide debug" : "Show debug"}
          </button>
          <button
            className="cg-toggle-btn"
            onClick={() => setShowElementList((s) => !s)}
          >
            {showElementList ? "Hide element list" : "Show element list"}
          </button>
        </div>

        <div className="mt-4">
          <div className="font-medium">Generators (legend)</div>
          <div className="mt-2">
            {generatorNames.map((g, i) => (
              <div key={i} className="flex items-center gap-2 mt-1">
                <div
                  style={{
                    width: 12,
                    height: 12,
                    background: PALETTE[i % PALETTE.length],
                    borderRadius: 2,
                  }}
                />
                <div className="text-sm text-gray-700">
                  {shortLabels[i] ?? `g${i}`} — {g}
                </div>
              </div>
            ))}
          </div>
        </div>

        <hr className="my-3" />

        <div>
          <div className="font-medium">Per-generator tensions</div>
          <div className="text-xs text-gray-600 mb-1">
            Higher tension -{">"} shorter target edges. Slider range: 0.1 .. 5.0
          </div>
          {generatorNames.map((g, i) => (
            <div key={`t-${i}`} className="mt-2">
              <div className="flex items-center justify-between text-sm">
                <div>
                  <span
                    style={{
                      display: "inline-block",
                      width: 12,
                      height: 12,
                      background: PALETTE[i % PALETTE.length],
                      marginRight: 8,
                    }}
                  ></span>
                  {shortLabels[i] ?? `g${i}`} — {g}
                </div>
                <div className="text-xs">{genTensions[i]?.toFixed(2)}</div>
              </div>
              <input
                type="range"
                min={0.1}
                max={5.0}
                step={0.01}
                value={genTensions[i] ?? 1.0}
                onChange={(e) => {
                  const v = parseFloat(e.target.value);
                  setGenTensions((old) => {
                    const next = old.slice();
                    next[i] = v;
                    return next;
                  });
                }}
                className="w-full"
              />
            </div>
          ))}
        </div>

        {showElementList ? (
          <div>
            <div className="flex items-center justify-between">
              <div className="font-medium mb-2">
                Elements (verification list)
              </div>
              <button
                className="cg-toggle-btn text-sm"
                onClick={() => setShowElementList(false)}
              >
                Hide
              </button>
            </div>
            <pre
              className="cg-element-list"
              style={{
                fontFamily: "monospace",
                fontSize: 12,
                whiteSpace: "pre-wrap",
              }}
            >
              {listing
                .map((L) => `${L.permStr}: ${L.wordLabel}  ${L.cycle}`)
                .join("\n")}
            </pre>
          </div>
        ) : (
          <div className="mt-2">
            <button
              className="cg-toggle-btn"
              onClick={() => setShowElementList(true)}
            >
              Show elements
            </button>
          </div>
        )}
      </div>

      <div className="flex-1 bg-black flex cg-canvas-container">
        <Canvas
          style={{ width: "100%", height: "100vh" }}
          dpr={[1, 2]}
          camera={{
            position: [
              0,
              0,
              Math.max(12, Math.pow(Math.max(1, count), 1 / 3) * 4),
            ],
            fov: 50,
          }}
        >
          <ambientLight intensity={0.6} />
          <directionalLight intensity={0.6} position={[5, 5, 5]} />

          <OrbitControls
            ref={controlsRef}
            enableZoom
            enablePan
            enableRotate
            zoomSpeed={0.8}
            rotateSpeed={0.6}
          />

          <AutoCamera count={count} />
          <Physics
            positionsRef={positionsRef}
            edgesRef={edgesRef}
            pinnedRef={pinnedRef}
            params={physicsParams}
            genTensionsRef={genTensionsRef}
          />

          <EdgeSegments
            key={`edges-${edges.length}`}
            edges={edges}
            positionsRef={positionsRef}
          />
          <ArrowHeads
            key={`arrows-${edges.length}`}
            edges={edges}
            positionsRef={positionsRef}
            size={0.16}
          />

          <InstancedNodes
            key={`nodes-${count}`}
            positionsRef={positionsRef}
            count={count}
            onClickInstance={handleClickInstance_new}
            onHoverInstance={handleHoverInstance}
            onDragStart={handleDragStart}
            onDrag={handleDrag}
            onDragEnd={handleDragEnd}
            nodeModesRef={nodeModesRef}
            nodesMeshRef={nodesMeshRef}
          />

          {showDebugOverlay && (
            <DebugOverlay
              positionsRef={positionsRef}
              edgesRef={edgesRef}
              nodeCount={count}
            />
          )}

          {(() => {
            if (!showLabels) return null;
            const positionsReady =
              positionsRef.current &&
              positionsReadyRef.current &&
              positionsRef.current.length >= nodeObjs.length;
            if (!positionsReady) return null;
            return nodeObjs.map((o, i) => {
              const posi = positionsRef.current[i];
              if (!posi) return null;
              return (
                <Html
                  key={"label-" + i}
                  distanceFactor={8}
                  style={{ pointerEvents: "none" }}
                  position={[posi.x, posi.y + 0.28, posi.z]}
                >
                  <div
                    style={{
                      background: "rgba(255,255,255,0.9)",
                      padding: "4px 6px",
                      borderRadius: 4,
                      fontSize: 12,
                    }}
                  >
                    {permTo1basedString(o.perm)}
                  </div>
                </Html>
              );
            });
          })()}

          {showLabels && count > 300 && (
            <Html
              distanceFactor={8}
              style={{ pointerEvents: "none" }}
              position={[0, 0, 0]}
            >
              <div
                style={{
                  background: "rgba(255,255,255,0.9)",
                  padding: "6px",
                  borderRadius: 6,
                  fontSize: 12,
                }}
              >
                Labels disabled for large graphs; hover nodes to see a label.
              </div>
            </Html>
          )}

          {hoverId != null &&
            positionsRef.current &&
            hoverId < positionsRef.current.length && (
              <Html
                distanceFactor={8}
                style={{ pointerEvents: "none" }}
                position={[
                  positionsRef.current[hoverId].x,
                  positionsRef.current[hoverId].y + 0.3,
                  positionsRef.current[hoverId].z,
                ]}
              >
                <div
                  style={{
                    background: "rgba(255,255,255,0.9)",
                    padding: "6px 8px",
                    borderRadius: 6,
                    fontSize: 12,
                  }}
                >
                  {permTo1basedString(nodeObjs[hoverId].perm)}
                  <br />
                  {listing[hoverId].wordLabel}
                </div>
              </Html>
            )}
        </Canvas>
      </div>
    </div>
  );
}
